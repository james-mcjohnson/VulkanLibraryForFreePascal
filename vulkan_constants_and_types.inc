{ Unlike OpenGL, most tokens in Vulkan are actual typed enumerants in
         their own numeric namespaces. The "name" attribute is the C enum
         type name, and is pulled in from a <type> definition above
         (slightly clunky, but retains the type / enum distinction). "type"
         attributes of "enum" or "bitmask" indicate that these values should
         be generated inside an appropriate definition. }


TVkImageLayout = (
  VK_IMAGE_LAYOUT_UNDEFINED = 0,                             // Implicit layout an image is when its contents are undefined due to various reasons (e.g. right after creation)
  VK_IMAGE_LAYOUT_GENERAL = 1,                               // General layout when image can be used for any kind of access
  VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,              // Optimal layout when image is only used for color attachment read/write
  VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,      // Optimal layout when image is only used for depth/stencil attachment read/write
  VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,       // Optimal layout when image is used for read only depth/stencil attachment and shader access
  VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,              // Optimal layout when image is used for read only shader access
  VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,                  // Optimal layout when image is used only as source of transfer operations
  VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,                  // Optimal layout when image is used only as destination of transfer operations
  VK_IMAGE_LAYOUT_PREINITIALIZED = 8,                        // Initial layout used when the data is populated by the CPU
  VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002
);

TVkAttachmentLoadOp = (
  VK_ATTACHMENT_LOAD_OP_LOAD = 0,
  VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
  VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2
);

TVkAttachmentStoreOp = (
  VK_ATTACHMENT_STORE_OP_STORE = 0,
  VK_ATTACHMENT_STORE_OP_DONT_CARE = 1
);

TVkImageType = (
  VK_IMAGE_TYPE_1D = 0,
  VK_IMAGE_TYPE_2D = 1,
  VK_IMAGE_TYPE_3D = 2
);

TVkImageTiling = (
  VK_IMAGE_TILING_OPTIMAL = 0,
  VK_IMAGE_TILING_LINEAR = 1
);

TVkImageViewType = (
  VK_IMAGE_VIEW_TYPE_1D = 0,
  VK_IMAGE_VIEW_TYPE_2D = 1,
  VK_IMAGE_VIEW_TYPE_3D = 2,
  VK_IMAGE_VIEW_TYPE_CUBE = 3,
  VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
  VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
  VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6
);

TVkCommandBufferLevel = (
  VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
  VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1
);

TVkComponentSwizzle = (
  VK_COMPONENT_SWIZZLE_IDENTITY = 0,
  VK_COMPONENT_SWIZZLE_ZERO = 1,
  VK_COMPONENT_SWIZZLE_ONE = 2,
  VK_COMPONENT_SWIZZLE_R = 3,
  VK_COMPONENT_SWIZZLE_G = 4,
  VK_COMPONENT_SWIZZLE_B = 5,
  VK_COMPONENT_SWIZZLE_A = 6
);

TVkDescriptorType = (
  VK_DESCRIPTOR_TYPE_SAMPLER = 0,
  VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
  VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
  VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
  VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
  VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
  VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
  VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
  VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
  VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10
);

TVkQueryType = (
  VK_QUERY_TYPE_OCCLUSION = 0,
  VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,                     // Optional
  VK_QUERY_TYPE_TIMESTAMP = 2
);

TVkBorderColor = (
  VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
  VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
  VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
  VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
  VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
  VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5
);

TVkPipelineBindPoint = (
  VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
  VK_PIPELINE_BIND_POINT_COMPUTE = 1
);

TVkPipelineCacheHeaderVersion = (
  VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1
);

TVkPrimitiveTopology = (
  VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
  VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
  VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
  VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
  VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
  VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
  VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10
);

TVkSharingMode = (
  VK_SHARING_MODE_EXCLUSIVE = 0,
  VK_SHARING_MODE_CONCURRENT = 1
);

TVkIndexType = (
  VK_INDEX_TYPE_UINT16 = 0,
  VK_INDEX_TYPE_UINT32 = 1
);

TVkFilter = (
  VK_FILTER_NEAREST = 0,
  VK_FILTER_LINEAR = 1,
  VK_FILTER_CUBIC_IMG = 1000015000
);

TVkSamplerMipmapMode = (
  VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,                        // Choose nearest mip level
  VK_SAMPLER_MIPMAP_MODE_LINEAR = 1                          // Linear filter between mip levels
);

TVkSamplerAddressMode = (
  VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
  VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
  VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
  VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3
);

{ <enum value="4"     name="VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE" comment="Reserved for VK_KHR_sampler_mirror_clamp_to_edge, do not alias!"/> }


TVkCompareOp = (
  VK_COMPARE_OP_NEVER = 0,
  VK_COMPARE_OP_LESS = 1,
  VK_COMPARE_OP_EQUAL = 2,
  VK_COMPARE_OP_LESS_OR_EQUAL = 3,
  VK_COMPARE_OP_GREATER = 4,
  VK_COMPARE_OP_NOT_EQUAL = 5,
  VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
  VK_COMPARE_OP_ALWAYS = 7
);

TVkPolygonMode = (
  VK_POLYGON_MODE_FILL = 0,
  VK_POLYGON_MODE_LINE = 1,
  VK_POLYGON_MODE_POINT = 2
);

TVkCullModeFlagBits_ = (
  VK_CULL_MODE_FRONT_BIT = 0,
  VK_CULL_MODE_BACK_BIT = 1
);
TVkCullModeFlagBits = set of TVkCullModeFlagBits_;
const
  VK_CULL_MODE_NONE = [];
  VK_CULL_MODE_FRONT_AND_BACK = [VK_CULL_MODE_FRONT_BIT, VK_CULL_MODE_BACK_BIT];
type

TVkFrontFace = (
  VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
  VK_FRONT_FACE_CLOCKWISE = 1
);

TVkBlendFactor = (
  VK_BLEND_FACTOR_ZERO = 0,
  VK_BLEND_FACTOR_ONE = 1,
  VK_BLEND_FACTOR_SRC_COLOR = 2,
  VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
  VK_BLEND_FACTOR_DST_COLOR = 4,
  VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
  VK_BLEND_FACTOR_SRC_ALPHA = 6,
  VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
  VK_BLEND_FACTOR_DST_ALPHA = 8,
  VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
  VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
  VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
  VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
  VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
  VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
  VK_BLEND_FACTOR_SRC1_COLOR = 15,
  VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
  VK_BLEND_FACTOR_SRC1_ALPHA = 17,
  VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18
);

TVkBlendOp = (
  VK_BLEND_OP_ADD = 0,
  VK_BLEND_OP_SUBTRACT = 1,
  VK_BLEND_OP_REVERSE_SUBTRACT = 2,
  VK_BLEND_OP_MIN = 3,
  VK_BLEND_OP_MAX = 4
);

TVkStencilOp = (
  VK_STENCIL_OP_KEEP = 0,
  VK_STENCIL_OP_ZERO = 1,
  VK_STENCIL_OP_REPLACE = 2,
  VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
  VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
  VK_STENCIL_OP_INVERT = 5,
  VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
  VK_STENCIL_OP_DECREMENT_AND_WRAP = 7
);

TVkLogicOp = (
  VK_LOGIC_OP_CLEAR = 0,
  VK_LOGIC_OP_AND = 1,
  VK_LOGIC_OP_AND_REVERSE = 2,
  VK_LOGIC_OP_COPY = 3,
  VK_LOGIC_OP_AND_INVERTED = 4,
  VK_LOGIC_OP_NO_OP = 5,
  VK_LOGIC_OP_XOR = 6,
  VK_LOGIC_OP_OR = 7,
  VK_LOGIC_OP_NOR = 8,
  VK_LOGIC_OP_EQUIVALENT = 9,
  VK_LOGIC_OP_INVERT = 10,
  VK_LOGIC_OP_OR_REVERSE = 11,
  VK_LOGIC_OP_COPY_INVERTED = 12,
  VK_LOGIC_OP_OR_INVERTED = 13,
  VK_LOGIC_OP_NAND = 14,
  VK_LOGIC_OP_SET = 15
);

TVkInternalAllocationType = (
  VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0
);

TVkSystemAllocationScope = (
  VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
  VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
  VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
  VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
  VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4
);

TVkPhysicalDeviceType = (
  VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
  VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
  VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
  VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
  VK_PHYSICAL_DEVICE_TYPE_CPU = 4
);

TVkVertexInputRate = (
  VK_VERTEX_INPUT_RATE_VERTEX = 0,
  VK_VERTEX_INPUT_RATE_INSTANCE = 1
);

TVkFormat = (
  VK_FORMAT_UNDEFINED = 0,
  VK_FORMAT_R4G4_UNORM_PACK8 = 1,
  VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
  VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
  VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
  VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
  VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
  VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
  VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
  VK_FORMAT_R8_UNORM = 9,
  VK_FORMAT_R8_SNORM = 10,
  VK_FORMAT_R8_USCALED = 11,
  VK_FORMAT_R8_SSCALED = 12,
  VK_FORMAT_R8_UINT = 13,
  VK_FORMAT_R8_SINT = 14,
  VK_FORMAT_R8_SRGB = 15,
  VK_FORMAT_R8G8_UNORM = 16,
  VK_FORMAT_R8G8_SNORM = 17,
  VK_FORMAT_R8G8_USCALED = 18,
  VK_FORMAT_R8G8_SSCALED = 19,
  VK_FORMAT_R8G8_UINT = 20,
  VK_FORMAT_R8G8_SINT = 21,
  VK_FORMAT_R8G8_SRGB = 22,
  VK_FORMAT_R8G8B8_UNORM = 23,
  VK_FORMAT_R8G8B8_SNORM = 24,
  VK_FORMAT_R8G8B8_USCALED = 25,
  VK_FORMAT_R8G8B8_SSCALED = 26,
  VK_FORMAT_R8G8B8_UINT = 27,
  VK_FORMAT_R8G8B8_SINT = 28,
  VK_FORMAT_R8G8B8_SRGB = 29,
  VK_FORMAT_B8G8R8_UNORM = 30,
  VK_FORMAT_B8G8R8_SNORM = 31,
  VK_FORMAT_B8G8R8_USCALED = 32,
  VK_FORMAT_B8G8R8_SSCALED = 33,
  VK_FORMAT_B8G8R8_UINT = 34,
  VK_FORMAT_B8G8R8_SINT = 35,
  VK_FORMAT_B8G8R8_SRGB = 36,
  VK_FORMAT_R8G8B8A8_UNORM = 37,
  VK_FORMAT_R8G8B8A8_SNORM = 38,
  VK_FORMAT_R8G8B8A8_USCALED = 39,
  VK_FORMAT_R8G8B8A8_SSCALED = 40,
  VK_FORMAT_R8G8B8A8_UINT = 41,
  VK_FORMAT_R8G8B8A8_SINT = 42,
  VK_FORMAT_R8G8B8A8_SRGB = 43,
  VK_FORMAT_B8G8R8A8_UNORM = 44,
  VK_FORMAT_B8G8R8A8_SNORM = 45,
  VK_FORMAT_B8G8R8A8_USCALED = 46,
  VK_FORMAT_B8G8R8A8_SSCALED = 47,
  VK_FORMAT_B8G8R8A8_UINT = 48,
  VK_FORMAT_B8G8R8A8_SINT = 49,
  VK_FORMAT_B8G8R8A8_SRGB = 50,
  VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
  VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
  VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
  VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
  VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
  VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
  VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
  VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
  VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
  VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
  VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
  VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
  VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
  VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
  VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
  VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
  VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
  VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
  VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
  VK_FORMAT_R16_UNORM = 70,
  VK_FORMAT_R16_SNORM = 71,
  VK_FORMAT_R16_USCALED = 72,
  VK_FORMAT_R16_SSCALED = 73,
  VK_FORMAT_R16_UINT = 74,
  VK_FORMAT_R16_SINT = 75,
  VK_FORMAT_R16_SFLOAT = 76,
  VK_FORMAT_R16G16_UNORM = 77,
  VK_FORMAT_R16G16_SNORM = 78,
  VK_FORMAT_R16G16_USCALED = 79,
  VK_FORMAT_R16G16_SSCALED = 80,
  VK_FORMAT_R16G16_UINT = 81,
  VK_FORMAT_R16G16_SINT = 82,
  VK_FORMAT_R16G16_SFLOAT = 83,
  VK_FORMAT_R16G16B16_UNORM = 84,
  VK_FORMAT_R16G16B16_SNORM = 85,
  VK_FORMAT_R16G16B16_USCALED = 86,
  VK_FORMAT_R16G16B16_SSCALED = 87,
  VK_FORMAT_R16G16B16_UINT = 88,
  VK_FORMAT_R16G16B16_SINT = 89,
  VK_FORMAT_R16G16B16_SFLOAT = 90,
  VK_FORMAT_R16G16B16A16_UNORM = 91,
  VK_FORMAT_R16G16B16A16_SNORM = 92,
  VK_FORMAT_R16G16B16A16_USCALED = 93,
  VK_FORMAT_R16G16B16A16_SSCALED = 94,
  VK_FORMAT_R16G16B16A16_UINT = 95,
  VK_FORMAT_R16G16B16A16_SINT = 96,
  VK_FORMAT_R16G16B16A16_SFLOAT = 97,
  VK_FORMAT_R32_UINT = 98,
  VK_FORMAT_R32_SINT = 99,
  VK_FORMAT_R32_SFLOAT = 100,
  VK_FORMAT_R32G32_UINT = 101,
  VK_FORMAT_R32G32_SINT = 102,
  VK_FORMAT_R32G32_SFLOAT = 103,
  VK_FORMAT_R32G32B32_UINT = 104,
  VK_FORMAT_R32G32B32_SINT = 105,
  VK_FORMAT_R32G32B32_SFLOAT = 106,
  VK_FORMAT_R32G32B32A32_UINT = 107,
  VK_FORMAT_R32G32B32A32_SINT = 108,
  VK_FORMAT_R32G32B32A32_SFLOAT = 109,
  VK_FORMAT_R64_UINT = 110,
  VK_FORMAT_R64_SINT = 111,
  VK_FORMAT_R64_SFLOAT = 112,
  VK_FORMAT_R64G64_UINT = 113,
  VK_FORMAT_R64G64_SINT = 114,
  VK_FORMAT_R64G64_SFLOAT = 115,
  VK_FORMAT_R64G64B64_UINT = 116,
  VK_FORMAT_R64G64B64_SINT = 117,
  VK_FORMAT_R64G64B64_SFLOAT = 118,
  VK_FORMAT_R64G64B64A64_UINT = 119,
  VK_FORMAT_R64G64B64A64_SINT = 120,
  VK_FORMAT_R64G64B64A64_SFLOAT = 121,
  VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
  VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
  VK_FORMAT_D16_UNORM = 124,
  VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
  VK_FORMAT_D32_SFLOAT = 126,
  VK_FORMAT_S8_UINT = 127,
  VK_FORMAT_D16_UNORM_S8_UINT = 128,
  VK_FORMAT_D24_UNORM_S8_UINT = 129,
  VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
  VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
  VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
  VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
  VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
  VK_FORMAT_BC2_UNORM_BLOCK = 135,
  VK_FORMAT_BC2_SRGB_BLOCK = 136,
  VK_FORMAT_BC3_UNORM_BLOCK = 137,
  VK_FORMAT_BC3_SRGB_BLOCK = 138,
  VK_FORMAT_BC4_UNORM_BLOCK = 139,
  VK_FORMAT_BC4_SNORM_BLOCK = 140,
  VK_FORMAT_BC5_UNORM_BLOCK = 141,
  VK_FORMAT_BC5_SNORM_BLOCK = 142,
  VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
  VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
  VK_FORMAT_BC7_UNORM_BLOCK = 145,
  VK_FORMAT_BC7_SRGB_BLOCK = 146,
  VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
  VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
  VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
  VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
  VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
  VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
  VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
  VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
  VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
  VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
  VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
  VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
  VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
  VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
  VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
  VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
  VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
  VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
  VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
  VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
  VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
  VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
  VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
  VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
  VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
  VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
  VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
  VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
  VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
  VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
  VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
  VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
  VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
  VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
  VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
  VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
  VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
  VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
  VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
  VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
  VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
  VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
  VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
  VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
  VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
  VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007
);

TVkStructureType = (
  VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
  VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
  VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
  VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
  VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
  VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
  VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
  VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
  VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
  VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
  VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
  VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
  VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
  VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
  VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
  VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
  VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
  VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
  VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
  VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
  VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
  VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
  VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
  VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
  VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
  VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
  VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
  VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
  VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
  VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
  VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
  VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
  VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
  VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
  VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
  VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
  VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
  VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
  VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
  VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
  VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
  VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
  { Reserved for internal use by the loader, layers, and ICDs }


  VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
  VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
  VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
  VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
  VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
  VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
  VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
  VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
  VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
  VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR = 1000007000,
  VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
  VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
  VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
  VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
  VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
  VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
  VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
  VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
  VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHX = 1000053000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHX = 1000053001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHX = 1000053002,
  VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
  VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
  VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
  VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
  VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR = 1000059000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR = 1000059001,
  VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR = 1000059002,
  VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR = 1000059003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = 1000059004,
  VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR = 1000059005,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = 1000059006,
  VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = 1000059007,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = 1000059008,
  VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHX = 1000060000,
  VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHX = 1000060001,
  VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHX = 1000060002,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHX = 1000060003,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHX = 1000060004,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHX = 1000060005,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHX = 1000060006,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHX = 1000060007,
  VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHX = 1000060008,
  VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHX = 1000060009,
  VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHX = 1000060010,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHX = 1000060011,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHX = 1000060012,
  VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
  VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHX = 1000070000,
  VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHX = 1000070001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHX = 1000071000,
  VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHX = 1000071001,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHX = 1000071002,
  VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHX = 1000071003,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHX = 1000071004,
  VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHX = 1000072000,
  VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHX = 1000072001,
  VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHX = 1000072002,
  VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHX = 1000073000,
  VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHX = 1000073001,
  VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHX = 1000073002,
  VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHX = 1000074000,
  VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHX = 1000074001,
  VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHX = 1000075000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHX = 1000076000,
  VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHX = 1000076001,
  VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHX = 1000077000,
  VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHX = 1000078000,
  VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHX = 1000078001,
  VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHX = 1000078002,
  VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHX = 1000079000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000,
  VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000,
  VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = 1000085000,
  VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX = 1000086000,
  VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX = 1000086001,
  VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX = 1000086002,
  VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX = 1000086003,
  VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX = 1000086004,
  VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX = 1000086005,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
  VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT = 1000090000,
  VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000,
  VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001,
  VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002,
  VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
  VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
  VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
  VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
  VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
  VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000,
  VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
  VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000
);

{ Reserved for internal use by the loader, layers, and ICDs }


TVkSubpassContents = (
  VK_SUBPASS_CONTENTS_INLINE = 0,
  VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1
);

TVkResult = (
  VK_ERROR_INVALID_EXTERNAL_HANDLE_KHX = -1000072003,
  VK_ERROR_OUT_OF_POOL_MEMORY_KHR = -1000069000,
  VK_NV_EXTENSION_1_ERROR = -1000013000,
  VK_ERROR_INVALID_SHADER_NV = -1000012000,
  VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
  VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
  VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
  VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
  VK_ERROR_SURFACE_LOST_KHR = -1000000000,
  VK_ERROR_FRAGMENTED_POOL = -12,                            // A requested pool allocation has failed due to fragmentation of the pool's memory
  VK_ERROR_FORMAT_NOT_SUPPORTED = -11,                       // Requested format is not supported on this device
  VK_ERROR_TOO_MANY_OBJECTS = -10,                           // Too many objects of the type have already been created
  VK_ERROR_INCOMPATIBLE_DRIVER = -9,                         // Unable to find a Vulkan driver
  VK_ERROR_FEATURE_NOT_PRESENT = -8,                         // Requested feature is not available on this device
  VK_ERROR_EXTENSION_NOT_PRESENT = -7,                       // Extension specified does not exist
  VK_ERROR_LAYER_NOT_PRESENT = -6,                           // Layer specified does not exist
  VK_ERROR_MEMORY_MAP_FAILED = -5,                           // Mapping of a memory object has failed
  VK_ERROR_DEVICE_LOST = -4,                                 // The logical device has been lost. See <<devsandqueues-lost-device>>
  VK_ERROR_INITIALIZATION_FAILED = -3,                       // Initialization of a object has failed
  VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,                        // A device memory allocation has failed
  { Error codes (negative values) }


  VK_ERROR_OUT_OF_HOST_MEMORY = -1,                          // A host memory allocation has failed
  { Return codes for successful operation execution (positive values) }


  VK_SUCCESS = 0,                                            // Command completed successfully
  VK_NOT_READY = 1,                                          // A fence or query has not yet completed
  VK_TIMEOUT = 2,                                            // A wait operation has not completed in the specified time
  VK_EVENT_SET = 3,                                          // An event is signaled
  VK_EVENT_RESET = 4,                                        // An event is unsignaled
  VK_INCOMPLETE = 5,                                         // A return array was too small for the result
  VK_SUBOPTIMAL_KHR = 1000001003
);
PVkResult = ^TVkResult;

TVkDynamicState = (
  VK_DYNAMIC_STATE_VIEWPORT = 0,
  VK_DYNAMIC_STATE_SCISSOR = 1,
  VK_DYNAMIC_STATE_LINE_WIDTH = 2,
  VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
  VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
  VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
  VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
  VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
  VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
  VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000,
  VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000
);
PVkDynamicState = ^TVkDynamicState;

TVkDescriptorUpdateTemplateTypeKHR = (
  VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = 0, // Create descriptor update template for descriptor set updates
  VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1 // Create descriptor update template for pushed descriptor updates
);

{ Flags }


TVkQueueFlagBits_ = (
  VK_QUEUE_GRAPHICS_BIT = 0,                                 // Queue supports graphics operations
  VK_QUEUE_COMPUTE_BIT = 1,                                  // Queue supports compute operations
  VK_QUEUE_TRANSFER_BIT = 2,                                 // Queue supports transfer operations
  VK_QUEUE_SPARSE_BINDING_BIT = 3                            // Queue supports sparse resource memory management operations
);
TVkQueueFlagBits = set of TVkQueueFlagBits_;

TVkMemoryPropertyFlagBits_ = (
  VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0,                   // If otherwise stated, then allocate memory on device
  VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 1,                   // Memory is mappable by host
  VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 2,                  // Memory will have i/o coherency. If not set, application may need to use vkFlushMappedMemoryRanges and vkInvalidateMappedMemoryRanges to flush/invalidate host cache
  VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 3,                    // Memory will be cached by the host
  VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 4                // Memory may be allocated by the driver when it is required
);
TVkMemoryPropertyFlagBits = set of TVkMemoryPropertyFlagBits_;

TVkMemoryHeapFlagBits_ = (
  VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0,                       // If set, heap represents device memory
  VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHX = 1
);
TVkMemoryHeapFlagBits = set of TVkMemoryHeapFlagBits_;

TVkAccessFlagBits_ = (
  VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0,                   // Controls coherency of indirect command reads
  VK_ACCESS_INDEX_READ_BIT = 1,                              // Controls coherency of index reads
  VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 2,                   // Controls coherency of vertex attribute reads
  VK_ACCESS_UNIFORM_READ_BIT = 3,                            // Controls coherency of uniform buffer reads
  VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 4,                   // Controls coherency of input attachment reads
  VK_ACCESS_SHADER_READ_BIT = 5,                             // Controls coherency of shader reads
  VK_ACCESS_SHADER_WRITE_BIT = 6,                            // Controls coherency of shader writes
  VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 7,                   // Controls coherency of color attachment reads
  VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 8,                  // Controls coherency of color attachment writes
  VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 9,           // Controls coherency of depth/stencil attachment reads
  VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 10,         // Controls coherency of depth/stencil attachment writes
  VK_ACCESS_TRANSFER_READ_BIT = 11,                          // Controls coherency of transfer reads
  VK_ACCESS_TRANSFER_WRITE_BIT = 12,                         // Controls coherency of transfer writes
  VK_ACCESS_HOST_READ_BIT = 13,                              // Controls coherency of host reads
  VK_ACCESS_HOST_WRITE_BIT = 14,                             // Controls coherency of host writes
  VK_ACCESS_MEMORY_READ_BIT = 15,                            // Controls coherency of memory reads
  VK_ACCESS_MEMORY_WRITE_BIT = 16,                           // Controls coherency of memory writes
  VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX = 17,
  VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX = 18
);
TVkAccessFlagBits = set of TVkAccessFlagBits_;

TVkBufferUsageFlagBits_ = (
  VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0,                      // Can be used as a source of transfer operations
  VK_BUFFER_USAGE_TRANSFER_DST_BIT = 1,                      // Can be used as a destination of transfer operations
  VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 2,              // Can be used as TBO
  VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 3,              // Can be used as IBO
  VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 4,                    // Can be used as UBO
  VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 5,                    // Can be used as SSBO
  VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 6,                      // Can be used as source of fixed-function index fetch (index buffer)
  VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 7,                     // Can be used as source of fixed-function vertex fetch (VBO)
  VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 8                    // Can be the source of indirect parameters (e.g. indirect buffer, parameter buffer)
);
TVkBufferUsageFlagBits = set of TVkBufferUsageFlagBits_;

TVkBufferCreateFlagBits_ = (
  VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0,                   // Buffer should support sparse backing
  VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 1,                 // Buffer should support sparse backing with partial residency
  VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 2                    // Buffer should support constent data access to physical memory ranges mapped into multiple locations of sparse buffers
);
TVkBufferCreateFlagBits = set of TVkBufferCreateFlagBits_;

TVkShaderStageFlagBits_ = (
  VK_SHADER_STAGE_VERTEX_BIT = 0,
  VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 1,
  VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 2,
  VK_SHADER_STAGE_GEOMETRY_BIT = 3,
  VK_SHADER_STAGE_FRAGMENT_BIT = 4,
  VK_SHADER_STAGE_COMPUTE_BIT = 5
);
TVkShaderStageFlagBits = set of TVkShaderStageFlagBits_;
const
  VK_SHADER_STAGE_ALL_GRAPHICS = [VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, VK_SHADER_STAGE_GEOMETRY_BIT, VK_SHADER_STAGE_FRAGMENT_BIT];
  var
    VK_SHADER_STAGE_ALL: set of TVkShaderStageFlagBits_;
type

TVkImageUsageFlagBits_ = (
  VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0,                       // Can be used as a source of transfer operations
  VK_IMAGE_USAGE_TRANSFER_DST_BIT = 1,                       // Can be used as a destination of transfer operations
  VK_IMAGE_USAGE_SAMPLED_BIT = 2,                            // Can be sampled from (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
  VK_IMAGE_USAGE_STORAGE_BIT = 3,                            // Can be used as storage image (STORAGE_IMAGE descriptor type)
  VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 4,                   // Can be used as framebuffer color attachment
  VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 5,           // Can be used as framebuffer depth/stencil attachment
  VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 6,               // Image data not needed outside of rendering
  VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 7                    // Can be used as framebuffer input attachment
);
TVkImageUsageFlagBits = set of TVkImageUsageFlagBits_;

TVkImageCreateFlagBits_ = (
  VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0,                    // Image should support sparse backing
  VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 1,                  // Image should support sparse backing with partial residency
  VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 2,                    // Image should support constent data access to physical memory ranges mapped into multiple locations of sparse images
  VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 3,                    // Allows image views to have different format than the base image
  VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 4,                   // Allows creating image views with cube type from the created image
  VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR = 5,
  VK_IMAGE_CREATE_BIND_SFR_BIT_KHX = 6
);
TVkImageCreateFlagBits = set of TVkImageCreateFlagBits_;

TVkPipelineCreateFlagBits_ = (
  VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0,
  VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 1,
  VK_PIPELINE_CREATE_DERIVATIVE_BIT = 2,
  VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHX = 3,
  VK_PIPELINE_CREATE_DISPATCH_BASE_KHX = 4
);
TVkPipelineCreateFlagBits = set of TVkPipelineCreateFlagBits_;

TVkColorComponentFlagBits_ = (
  VK_COLOR_COMPONENT_R_BIT = 0,
  VK_COLOR_COMPONENT_G_BIT = 1,
  VK_COLOR_COMPONENT_B_BIT = 2,
  VK_COLOR_COMPONENT_A_BIT = 3
);
TVkColorComponentFlagBits = set of TVkColorComponentFlagBits_;

TVkFenceCreateFlagBits_ = (
  VK_FENCE_CREATE_SIGNALED_BIT = 0
);
TVkFenceCreateFlagBits = set of TVkFenceCreateFlagBits_;

TVkFormatFeatureFlagBits_ = (
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0,                   // Format can be used for sampled images (SAMPLED_IMAGE and COMBINED_IMAGE_SAMPLER descriptor types)
  VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 1,                   // Format can be used for storage images (STORAGE_IMAGE descriptor type)
  VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 2,            // Format supports atomic operations in case it is used for storage images
  VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 3,            // Format can be used for uniform texel buffers (TBOs)
  VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 4,            // Format can be used for storage texel buffers (IBOs)
  VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 5,     // Format supports atomic operations in case it is used for storage texel buffers
  VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 6,                   // Format can be used for vertex buffers (VBOs)
  VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 7,                // Format can be used for color attachment images
  VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 8,          // Format supports blending in case it is used for color attachment images
  VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 9,        // Format can be used for depth/stencil attachment images
  VK_FORMAT_FEATURE_BLIT_SRC_BIT = 10,                       // Format can be used as the source image of blits with vkCmdBlitImage
  VK_FORMAT_FEATURE_BLIT_DST_BIT = 11,                       // Format can be used as the destination image of blits with vkCmdBlitImage
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 12,    // Format can be filtered with VK_FILTER_LINEAR when being sampled
  VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 13,
  VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR = 14,
  VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR = 15
);
TVkFormatFeatureFlagBits = set of TVkFormatFeatureFlagBits_;

TVkQueryControlFlagBits_ = (
  VK_QUERY_CONTROL_PRECISE_BIT = 0                           // Require precise results to be collected by the query
);
TVkQueryControlFlagBits = set of TVkQueryControlFlagBits_;

TVkQueryResultFlagBits_ = (
  VK_QUERY_RESULT_64_BIT = 0,                                // Results of the queries are written to the destination buffer as 64-bit values
  VK_QUERY_RESULT_WAIT_BIT = 1,                              // Results of the queries are waited on before proceeding with the result copy
  VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 2,                 // Besides the results of the query, the availability of the results is also written
  VK_QUERY_RESULT_PARTIAL_BIT = 3                            // Copy the partial results of the query even if the final results are not available
);
TVkQueryResultFlagBits = set of TVkQueryResultFlagBits_;

TVkCommandBufferUsageFlagBits_ = (
  VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0,
  VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 1,
  VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 2           // Command buffer may be submitted/executed more than once simultaneously
);
TVkCommandBufferUsageFlagBits = set of TVkCommandBufferUsageFlagBits_;

TVkQueryPipelineStatisticFlagBits_ = (
  VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0, // Optional
  VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 1, // Optional
  VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 2, // Optional
  VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 3, // Optional
  VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 4, // Optional
  VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 5,  // Optional
  VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 6,   // Optional
  VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 7, // Optional
  VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 8, // Optional
  VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 9, // Optional
  VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 10 // Optional
);
TVkQueryPipelineStatisticFlagBits = set of TVkQueryPipelineStatisticFlagBits_;

TVkImageAspectFlagBits_ = (
  VK_IMAGE_ASPECT_COLOR_BIT = 0,
  VK_IMAGE_ASPECT_DEPTH_BIT = 1,
  VK_IMAGE_ASPECT_STENCIL_BIT = 2,
  VK_IMAGE_ASPECT_METADATA_BIT = 3
);
TVkImageAspectFlagBits = set of TVkImageAspectFlagBits_;

TVkSparseImageFormatFlagBits_ = (
  VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0,             // Image uses a single mip tail region for all array layers
  VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 1,           // Image requires mip level dimensions to be an integer multiple of the sparse image block dimensions for non-tail mip levels.
  VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 2      // Image uses a non-standard sparse image block dimensions
);
TVkSparseImageFormatFlagBits = set of TVkSparseImageFormatFlagBits_;

TVkSparseMemoryBindFlagBits_ = (
  VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0                     // Operation binds resource metadata to memory
);
TVkSparseMemoryBindFlagBits = set of TVkSparseMemoryBindFlagBits_;

TVkPipelineStageFlagBits_ = (
  VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0,                     // Before subsequent commands are processed
  VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 1,                   // Draw/DispatchIndirect command fetch
  VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 2,                    // Vertex/index fetch
  VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 3,                   // Vertex shading
  VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 4,     // Tessellation control shading
  VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 5,  // Tessellation evaluation shading
  VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 6,                 // Geometry shading
  VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 7,                 // Fragment shading
  VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 8,            // Early fragment (depth and stencil) tests
  VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 9,             // Late fragment (depth and stencil) tests
  VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 10,        // Color attachment writes
  VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 11,                 // Compute shading
  VK_PIPELINE_STAGE_TRANSFER_BIT = 12,                       // Transfer/copy operations
  VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 13,                 // After previous commands have completed
  VK_PIPELINE_STAGE_HOST_BIT = 14,                           // Indicates host (CPU) is a source/sink of the dependency
  VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 15,                   // All stages of the graphics pipeline
  VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 16,                   // All stages supported on the queue
  VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX = 17
);
TVkPipelineStageFlagBits = set of TVkPipelineStageFlagBits_;

TVkCommandPoolCreateFlagBits_ = (
  VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0,                  // Command buffers have a short lifetime
  VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 1        // Command buffers may release their memory individually
);
TVkCommandPoolCreateFlagBits = set of TVkCommandPoolCreateFlagBits_;

TVkCommandPoolResetFlagBits_ = (
  VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0            // Release resources owned by the pool
);
TVkCommandPoolResetFlagBits = set of TVkCommandPoolResetFlagBits_;

TVkCommandBufferResetFlagBits_ = (
  VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0          // Release resources owned by the buffer
);
TVkCommandBufferResetFlagBits = set of TVkCommandBufferResetFlagBits_;

TVkSampleCountFlagBits_ = (
  VK_SAMPLE_COUNT_1_BIT = 0,                                 // Sample count 1 supported
  VK_SAMPLE_COUNT_2_BIT = 1,                                 // Sample count 2 supported
  VK_SAMPLE_COUNT_4_BIT = 2,                                 // Sample count 4 supported
  VK_SAMPLE_COUNT_8_BIT = 3,                                 // Sample count 8 supported
  VK_SAMPLE_COUNT_16_BIT = 4,                                // Sample count 16 supported
  VK_SAMPLE_COUNT_32_BIT = 5,                                // Sample count 32 supported
  VK_SAMPLE_COUNT_64_BIT = 6                                 // Sample count 64 supported
);
TVkSampleCountFlagBits = set of TVkSampleCountFlagBits_;

TVkAttachmentDescriptionFlagBits_ = (
  VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0                // The attachment may alias physical memory of another attachment in the same render pass
);
TVkAttachmentDescriptionFlagBits = set of TVkAttachmentDescriptionFlagBits_;

TVkStencilFaceFlagBits_ = (
  VK_STENCIL_FACE_FRONT_BIT = 0,                             // Front face
  VK_STENCIL_FACE_BACK_BIT = 1                               // Back face
);
TVkStencilFaceFlagBits = set of TVkStencilFaceFlagBits_;
const
  VK_STENCIL_FRONT_AND_BACK = [VK_STENCIL_FACE_FRONT_BIT, VK_STENCIL_FACE_BACK_BIT];
type

TVkDescriptorPoolCreateFlagBits_ = (
  VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0      // Descriptor sets may be freed individually
);
TVkDescriptorPoolCreateFlagBits = set of TVkDescriptorPoolCreateFlagBits_;

TVkDependencyFlagBits_ = (
  VK_DEPENDENCY_BY_REGION_BIT = 0,                           // Dependency is per pixel region
  VK_DEPENDENCY_VIEW_LOCAL_BIT_KHX = 1,
  VK_DEPENDENCY_DEVICE_GROUP_BIT_KHX = 2
);
TVkDependencyFlagBits = set of TVkDependencyFlagBits_;

{ WSI extensions }


TVkPresentModeKHR = (
  VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
  VK_PRESENT_MODE_MAILBOX_KHR = 1,
  VK_PRESENT_MODE_FIFO_KHR = 2,
  VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3
);
PVkPresentModeKHR = ^TVkPresentModeKHR;

TVkColorSpaceKHR = (
  VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
  VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001,
  VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002,
  VK_COLOR_SPACE_DCI_P3_LINEAR_EXT = 1000104003,
  VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004,
  VK_COLOR_SPACE_BT709_LINEAR_EXT = 1000104005,
  VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006,
  VK_COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007,
  VK_COLOR_SPACE_HDR10_ST2084_EXT = 1000104008,
  VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009,
  VK_COLOR_SPACE_HDR10_HLG_EXT = 1000104010,
  VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011,
  VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012,
  VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013
);

TVkDisplayPlaneAlphaFlagBitsKHR_ = (
  VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0,
  VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 1,
  VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 2,
  VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 3
);
TVkDisplayPlaneAlphaFlagBitsKHR = set of TVkDisplayPlaneAlphaFlagBitsKHR_;

TVkCompositeAlphaFlagBitsKHR_ = (
  VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0,
  VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 1,
  VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 2,
  VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 3
);
TVkCompositeAlphaFlagBitsKHR = set of TVkCompositeAlphaFlagBitsKHR_;

TVkSurfaceTransformFlagBitsKHR_ = (
  VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0,
  VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 1,
  VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 2,
  VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 3,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 4,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 5,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 6,
  VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 7,
  VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 8
);
TVkSurfaceTransformFlagBitsKHR = set of TVkSurfaceTransformFlagBitsKHR_;

TVkDebugReportFlagBitsEXT_ = (
  VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 0,
  VK_DEBUG_REPORT_WARNING_BIT_EXT = 1,
  VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 2,
  VK_DEBUG_REPORT_ERROR_BIT_EXT = 3,
  VK_DEBUG_REPORT_DEBUG_BIT_EXT = 4
);
TVkDebugReportFlagBitsEXT = set of TVkDebugReportFlagBitsEXT_;

TVkDebugReportObjectTypeEXT = (
  VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
  VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
  VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
  VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
  VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
  VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
  VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
  VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
  VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
  VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
  VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
  VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
  VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
  VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
  VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
  VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
  VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
  VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
  VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
  VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
  VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = 28,
  VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
  VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
  VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT = 31,
  VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT = 32,
  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = 1000085000
);

TVkDebugReportErrorEXT = (
  VK_DEBUG_REPORT_ERROR_NONE_EXT = 0,
  { Used for INFO & other non-error messages }


  VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT = 1
);

{ Callbacks were not destroyed prior to calling DestroyInstance }


TVkRasterizationOrderAMD = (
  VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
  { Rasterization order strictly follows API order }


  VK_RASTERIZATION_ORDER_RELAXED_AMD = 1
);

{ Rasterization order may not follow API order }


TVkExternalMemoryHandleTypeFlagBitsNV_ = (
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 0,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 1,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 2,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 3
);
TVkExternalMemoryHandleTypeFlagBitsNV = set of TVkExternalMemoryHandleTypeFlagBitsNV_;

TVkExternalMemoryFeatureFlagBitsNV_ = (
  VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 0,
  VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 1,
  VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 2
);
TVkExternalMemoryFeatureFlagBitsNV = set of TVkExternalMemoryFeatureFlagBitsNV_;

TVkValidationCheckEXT = (
  VK_VALIDATION_CHECK_ALL_EXT = 0
);
PVkValidationCheckEXT = ^TVkValidationCheckEXT;

{ Placeholder for validation enums to be defined for VK_EXT_Validation_flags extension }


TVkIndirectCommandsLayoutUsageFlagBitsNVX_ = (
  VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX = 0,
  { sequences can be processed in implementation-dependent order }


  VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX = 1,
  { likely generated with a high difference in actual sequencesCount and maxSequencesCount }


  VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX = 2,
  { likely to contain draw/dispatch calls that are zero-sized }


  VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX = 3
);
TVkIndirectCommandsLayoutUsageFlagBitsNVX = set of TVkIndirectCommandsLayoutUsageFlagBitsNVX_;

{ custom sequence index permutation (32-bit) is provided }


TVkObjectEntryUsageFlagBitsNVX_ = (
  VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX = 0,
  VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX = 1
);
TVkObjectEntryUsageFlagBitsNVX = set of TVkObjectEntryUsageFlagBitsNVX_;

TVkIndirectCommandsTokenTypeNVX = (
  VK_INDIRECT_COMMANDS_TOKEN_PIPELINE_NVX = 0,
  { array of 32bit tableEntry in the object table }


  VK_INDIRECT_COMMANDS_TOKEN_DESCRIPTOR_SET_NVX = 1,
  { array of (32 bit tableEntry + variable count 32bit offsets) }


  VK_INDIRECT_COMMANDS_TOKEN_INDEX_BUFFER_NVX = 2,
  { array of (32 bit tableEntry + optional 32bit offset) }


  VK_INDIRECT_COMMANDS_TOKEN_VERTEX_BUFFER_NVX = 3,
  { array of (32 bit tableEntry + optional 32bit offset) }


  VK_INDIRECT_COMMANDS_TOKEN_PUSH_CONSTANT_NVX = 4,
  { array of (32 bit tableEntry + variable count 32bit values ) }


  VK_INDIRECT_COMMANDS_TOKEN_DRAW_INDEXED_NVX = 5,
  { array of VkDrawIndexedIndirectCommand }


  VK_INDIRECT_COMMANDS_TOKEN_DRAW_NVX = 6,
  { array of VkDrawIndirectCommand }


  VK_INDIRECT_COMMANDS_TOKEN_DISPATCH_NVX = 7
);

{ array of VkDispatchIndirectCommand }


TVkObjectEntryTypeNVX = (
  VK_OBJECT_ENTRY_DESCRIPTOR_SET_NVX = 0,
  VK_OBJECT_ENTRY_PIPELINE_NVX = 1,
  VK_OBJECT_ENTRY_INDEX_BUFFER_NVX = 2,
  VK_OBJECT_ENTRY_VERTEX_BUFFER_NVX = 3,
  VK_OBJECT_ENTRY_PUSH_CONSTANT_NVX = 4
);
PVkObjectEntryTypeNVX = ^TVkObjectEntryTypeNVX;

TVkDescriptorSetLayoutCreateFlagBits_ = (
  VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 0
);
TVkDescriptorSetLayoutCreateFlagBits = set of TVkDescriptorSetLayoutCreateFlagBits_;

TVkExternalMemoryHandleTypeFlagBitsKHX_ = (
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHX = 0,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHX = 1,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHX = 2,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHX = 3,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHX = 4,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHX = 5,
  VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHX = 6
);
TVkExternalMemoryHandleTypeFlagBitsKHX = set of TVkExternalMemoryHandleTypeFlagBitsKHX_;

TVkExternalMemoryFeatureFlagBitsKHX_ = (
  VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHX = 0,
  VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHX = 1,
  VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHX = 2
);
TVkExternalMemoryFeatureFlagBitsKHX = set of TVkExternalMemoryFeatureFlagBitsKHX_;

TVkExternalSemaphoreHandleTypeFlagBitsKHX_ = (
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHX = 0,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHX = 1,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHX = 2,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHX = 3,
  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FENCE_FD_BIT_KHX = 4
);
TVkExternalSemaphoreHandleTypeFlagBitsKHX = set of TVkExternalSemaphoreHandleTypeFlagBitsKHX_;

TVkExternalSemaphoreFeatureFlagBitsKHX_ = (
  VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHX = 0,
  VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHX = 1
);
TVkExternalSemaphoreFeatureFlagBitsKHX = set of TVkExternalSemaphoreFeatureFlagBitsKHX_;

TVkSurfaceCounterFlagBitsEXT_ = (
  VK_SURFACE_COUNTER_VBLANK_EXT = 0
);
TVkSurfaceCounterFlagBitsEXT = set of TVkSurfaceCounterFlagBitsEXT_;

TVkDisplayPowerStateEXT = (
  VK_DISPLAY_POWER_STATE_OFF_EXT = 0,
  VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1,
  VK_DISPLAY_POWER_STATE_ON_EXT = 2
);

TVkDeviceEventTypeEXT = (
  VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0
);

TVkDisplayEventTypeEXT = (
  VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0
);

TVkPeerMemoryFeatureFlagBitsKHX_ = (
  VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHX = 0,               // Can read with vkCmdCopy commands
  VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHX = 1,               // Can write with vkCmdCopy commands
  VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHX = 2,            // Can read with any access type/command
  VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHX = 3             // Can write with and access type/command
);
TVkPeerMemoryFeatureFlagBitsKHX = set of TVkPeerMemoryFeatureFlagBitsKHX_;

TVkMemoryAllocateFlagBitsKHX_ = (
  VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHX = 0                 // Force allocation on specific devices
);
TVkMemoryAllocateFlagBitsKHX = set of TVkMemoryAllocateFlagBitsKHX_;

TVkDeviceGroupPresentModeFlagBitsKHX_ = (
  VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHX = 0,            // Present from local memory
  VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHX = 1,           // Present from remote memory
  VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHX = 2,              // Present sum of local and/or remote memory
  VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHX = 3 // Each physical device presents from local memory
);
TVkDeviceGroupPresentModeFlagBitsKHX = set of TVkDeviceGroupPresentModeFlagBitsKHX_;

TVkSwapchainCreateFlagBitsKHR_ = (
  VK_SWAPCHAIN_CREATE_BIND_SFR_BIT_KHX = 0
);
TVkSwapchainCreateFlagBitsKHR = set of TVkSwapchainCreateFlagBitsKHR_;

TVkViewportCoordinateSwizzleNV = (
  VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0,
  VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1,
  VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2,
  VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3,
  VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4,
  VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5,
  VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6,
  VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7
);

TVkDiscardRectangleModeEXT = (
  VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0,
  VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1
);

TVkSubpassDescriptionFlagBits_ = (
  VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 0,
  VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 1
);
TVkSubpassDescriptionFlagBits = set of TVkSubpassDescriptionFlagBits_;


const
    (*
    Copyright (c) 2015-2017 The Khronos Group Inc.
    
    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and/or associated documentation files (the
    "Materials"), to deal in the Materials without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Materials, and to
    permit persons to whom the Materials are furnished to do so, subject to
    the following conditions:
    
    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Materials.
    
    THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
    
    ------------------------------------------------------------------------
    
    This file, vk.xml, is the Vulkan API Registry. It is a critically important
    and normative part of the Vulkan Specification, including a canonical
    machine-readable definition of the API, parameter and member validation
    language incorporated into the Specification and reference pages, and other
    material which is registered by Khronos, such as tags used by extension and
    layer authors. The only authoritative version of vk.xml is the one
    maintained in the master branch of the Khronos Vulkan GitHub project.
  *)

  { SECTION: Vulkan vendor IDs for physical devices without PCI vendor IDs }


  KHR = $10000;                                              // This is the next available Khronos vendor ID
  VIV = $10001;                                              // Vivante vendor ID
  VSI = $10002;                                              // VeriSilicon vendor ID
  { SECTION: Vulkan vendor/author tags for extensions and layers }


  IMG_tag = 'Imagination Technologies';                      // contact: Michael Worcester @michaelworcester
  AMD_tag = 'Advanced Micro Devices, Inc.';                  // contact: Daniel Rakos @aqnuep
  ARM_tag = 'ARM Limited';                                   // contact: Jan-Harald Fredriksen @janharald
  FSL_tag = 'Freescale Semiconductor, Inc.';                 // contact: Norbert Nopper @FslNopper
  BRCM_tag = 'Broadcom Corporation';                         // contact: Graeme Leese @gnl21
  NXP_tag = 'NXP Semiconductors N.V.';                       // contact: Norbert Nopper @FslNopper
  NV_tag = 'NVIDIA Corporation';                             // contact: Daniel Koch @dgkoch
  NVX_tag = 'NVIDIA Corporation';                            // contact: Daniel Koch @dgkoch
  VIV_tag = 'Vivante Corporation';                           // contact: Yanjun Zhang @yanjunzhang
  VSI_tag = 'VeriSilicon Holdings Co., Ltd.';                // contact: Yanjun Zhang @yanjunzhang
  KDAB_tag = 'KDAB';                                         // contact: Sean Harmer @seanharmer
  ANDROID_tag = 'Google, Inc.';                              // contact: Jesse Hall @jessehall
  CHROMIUM_tag = 'Google, Inc.';                             // contact: Jesse Hall @jessehall
  GOOGLE_tag = 'Google, Inc.';                               // contact: Jesse Hall @jessehall
  QCOM_tag = 'Qualcomm Technologies, Inc.';                  // contact: Maurice Ribble @mribble
  LUNARG_tag = 'LunarG, Inc.';                               // contact: Karen Ghavam @KarenGhavam
  SAMSUNG_tag = 'Samsung Electronics Co., Ltd.';             // contact: Alon Or-bach @alonorbach
  SEC_tag = 'Samsung Electronics Co., Ltd.';                 // contact: Alon Or-bach @alonorbach
  TIZEN_tag = 'Samsung Electronics Co., Ltd.';               // contact: Alon Or-bach @alonorbach
  RENDERDOC_tag = 'RenderDoc (renderdoc.org)';               // contact: baldurk@baldurk.org
  NN_tag = 'Nintendo Co., Ltd.';                             // contact: Yasuhiro Yoshioka @yoshioka_yasuhiro
  MVK_tag = 'The Brenwill Workshop Ltd.';                    // contact: Bill Hollings @billhollings
  KHR_tag = 'Khronos';                                       // contact: Tom Olson @tom.olson
  EXT_tag = 'Multivendor';                                   // contact: Jon Leech @oddhack
  MESA_tag = 'Mesa open source project';                     // contact: Chad Versace @chadversary, Daniel Stone @fooishbar, David Airlie @airlied, Jason Ekstrand @jekstrand
  { SECTION: Vulkan enumerant (token) definitions. }


  VK_MAX_PHYSICAL_DEVICE_NAME_SIZE = 256;
  VK_UUID_SIZE = 16;
  VK_LUID_SIZE_KHX = 8;
  VK_MAX_EXTENSION_NAME_SIZE = 256;
  VK_MAX_DESCRIPTION_SIZE = 256;
  VK_MAX_MEMORY_TYPES = 32;
  VK_MAX_MEMORY_HEAPS = 16;
  VK_LOD_CLAMP_NONE = 1000.0;
  VK_REMAINING_MIP_LEVELS = (not 0);
  VK_REMAINING_ARRAY_LAYERS = (not 0);
  VK_WHOLE_SIZE = (not 0);
  VK_ATTACHMENT_UNUSED = (not 0);
  VK_TRUE = 1;
  VK_FALSE = 0;
  VK_QUEUE_FAMILY_IGNORED = (not 0);
  VK_QUEUE_FAMILY_EXTERNAL_KHX = ((not 0) - 1);
  VK_SUBPASS_EXTERNAL = (not 0);
  VK_MAX_DEVICE_GROUP_SIZE_KHX = 32;
  VK_KHR_SURFACE_SPEC_VERSION = 25;
  VK_KHR_SURFACE_EXTENSION_NAME = 'VK_KHR_surface';
  VK_COLORSPACE_SRGB_NONLINEAR_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
  VK_KHR_SWAPCHAIN_SPEC_VERSION = 68;
  VK_KHR_SWAPCHAIN_EXTENSION_NAME = 'VK_KHR_swapchain';
  VK_KHR_DISPLAY_SPEC_VERSION = 21;
  VK_KHR_DISPLAY_EXTENSION_NAME = 'VK_KHR_display';
  VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION = 9;
  VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME = 'VK_KHR_display_swapchain';
  VK_KHR_XLIB_SURFACE_SPEC_VERSION = 6;
  VK_KHR_XLIB_SURFACE_EXTENSION_NAME = 'VK_KHR_xlib_surface';
  VK_KHR_XCB_SURFACE_SPEC_VERSION = 6;
  VK_KHR_XCB_SURFACE_EXTENSION_NAME = 'VK_KHR_xcb_surface';
  VK_KHR_WAYLAND_SURFACE_SPEC_VERSION = 6;
  VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME = 'VK_KHR_wayland_surface';
  VK_KHR_MIR_SURFACE_SPEC_VERSION = 4;
  VK_KHR_MIR_SURFACE_EXTENSION_NAME = 'VK_KHR_mir_surface';
  VK_KHR_ANDROID_SURFACE_SPEC_VERSION = 6;
  VK_KHR_ANDROID_SURFACE_EXTENSION_NAME = 'VK_KHR_android_surface';
  VK_KHR_WIN32_SURFACE_SPEC_VERSION = 5;
  VK_KHR_WIN32_SURFACE_EXTENSION_NAME = 'VK_KHR_win32_surface';
  VK_ANDROID_NATIVE_BUFFER_SPEC_VERSION = 4;
  VK_ANDROID_NATIVE_BUFFER_NUMBER = 11;
  VK_ANDROID_NATIVE_BUFFER_NAME = 'VK_ANDROID_native_buffer';
  VK_EXT_DEBUG_REPORT_SPEC_VERSION = 6;
  VK_EXT_DEBUG_REPORT_EXTENSION_NAME = 'VK_EXT_debug_report';
  VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT;
  VK_NV_GLSL_SHADER_SPEC_VERSION = 1;
  VK_NV_GLSL_SHADER_EXTENSION_NAME = 'VK_NV_glsl_shader';
  VK_NV_EXTENSION_1_SPEC_VERSION = 0;
  VK_NV_EXTENSION_1_EXTENSION_NAME = 'VK_NV_extension_1';
  VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION = 1;
  VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME = 'VK_KHR_sampler_mirror_clamp_to_edge';
  VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4;
  VK_IMG_FILTER_CUBIC_SPEC_VERSION = 1;
  VK_IMG_FILTER_CUBIC_EXTENSION_NAME = 'VK_IMG_filter_cubic';
  VK_AMD_EXTENSION_17_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_17_EXTENSION_NAME = 'VK_AMD_extension_17';
  VK_AMD_EXTENSION_18_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_18_EXTENSION_NAME = 'VK_AMD_extension_18';
  VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION = 1;
  VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME = 'VK_AMD_rasterization_order';
  VK_AMD_EXTENSION_20_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_20_EXTENSION_NAME = 'VK_AMD_extension_20';
  VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION = 1;
  VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME = 'VK_AMD_shader_trinary_minmax';
  VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION = 1;
  VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME = 'VK_AMD_shader_explicit_vertex_parameter';
  VK_EXT_DEBUG_MARKER_SPEC_VERSION = 4;
  VK_EXT_DEBUG_MARKER_EXTENSION_NAME = 'VK_EXT_debug_marker';
  VK_AMD_EXTENSION_24_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_24_EXTENSION_NAME = 'VK_AMD_extension_24';
  VK_AMD_EXTENSION_25_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_25_EXTENSION_NAME = 'VK_AMD_extension_25';
  VK_AMD_GCN_SHADER_SPEC_VERSION = 1;
  VK_AMD_GCN_SHADER_EXTENSION_NAME = 'VK_AMD_gcn_shader';
  VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION = 1;
  VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME = 'VK_NV_dedicated_allocation';
  VK_EXT_EXTENSION_28_SPEC_VERSION = 0;
  VK_EXT_EXTENSION_28_EXTENSION_NAME = 'VK_NV_extension_28';
  VK_NVX_EXTENSION_29_SPEC_VERSION = 0;
  VK_NVX_EXTENSION_29_EXTENSION_NAME = 'VK_NVX_extension_29';
  VK_NVX_EXTENSION_30_SPEC_VERSION = 0;
  VK_NVX_EXTENSION_30_EXTENSION_NAME = 'VK_NVX_extension_30';
  VK_NVX_EXTENSION_31_SPEC_VERSION = 0;
  VK_NVX_EXTENSION_31_EXTENSION_NAME = 'VK_NVX_extension_31';
  VK_AMD_EXTENSION_32_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_32_EXTENSION_NAME = 'VK_AMD_extension_32';
  VK_AMD_EXTENSION_33_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_33_EXTENSION_NAME = 'VK_AMD_extension_33';
  VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION = 1;
  VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME = 'VK_AMD_draw_indirect_count';
  VK_AMD_EXTENSION_35_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_35_EXTENSION_NAME = 'VK_AMD_extension_35';
  VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION = 1;
  VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME = 'VK_AMD_negative_viewport_height';
  VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION = 1;
  VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME = 'VK_AMD_gpu_shader_half_float';
  VK_AMD_SHADER_BALLOT_SPEC_VERSION = 1;
  VK_AMD_SHADER_BALLOT_EXTENSION_NAME = 'VK_AMD_shader_ballot';
  VK_AMD_EXTENSION_39_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_39_EXTENSION_NAME = 'VK_AMD_extension_39';
  VK_AMD_EXTENSION_40_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_40_EXTENSION_NAME = 'VK_AMD_extension_40';
  VK_AMD_EXTENSION_41_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_41_EXTENSION_NAME = 'VK_AMD_extension_41';
  VK_AMD_EXTENSION_42_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_42_EXTENSION_NAME = 'VK_AMD_extension_42';
  VK_AMD_EXTENSION_43_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_43_EXTENSION_NAME = 'VK_AMD_extension_43';
  VK_AMD_EXTENSION_44_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_44_EXTENSION_NAME = 'VK_AMD_extension_44';
  VK_AMD_EXTENSION_45_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_45_EXTENSION_NAME = 'VK_AMD_extension_45';
  VK_AMD_EXTENSION_46_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_46_EXTENSION_NAME = 'VK_AMD_extension_46';
  VK_AMD_EXTENSION_47_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_47_EXTENSION_NAME = 'VK_AMD_extension_47';
  VK_NVX_EXTENSION_48_SPEC_VERSION = 0;
  VK_NVX_EXTENSION_48_EXTENSION_NAME = 'VK_NVX_extension_48';
  VK_GOOGLE_EXTENSION_49_SPEC_VERSION = 0;
  VK_GOOGLE_EXTENSION_49_EXTENSION_NAME = 'VK_GOOGLE_extension_49';
  VK_GOOGLE_EXTENSION_50_SPEC_VERSION = 0;
  VK_GOOGLE_EXTENSION_50_EXTENSION_NAME = 'VK_GOOGLE_extension_50';
  VK_NVX_EXTENSION_51_SPEC_VERSION = 0;
  VK_NVX_EXTENSION_51_EXTENSION_NAME = 'VK_NVX_extension_51';
  VK_NVX_EXTENSION_52_SPEC_VERSION = 0;
  VK_NVX_EXTENSION_52_EXTENSION_NAME = 'VK_NVX_extension_52';
  VK_NV_EXTENSION_53_SPEC_VERSION = 0;
  VK_NV_EXTENSION_53_EXTENSION_NAME = 'VK_NV_extension_53';
  VK_KHX_MULTIVIEW_SPEC_VERSION = 1;
  VK_KHX_MULTIVIEW_EXTENSION_NAME = 'VK_KHX_multiview';
  VK_IMG_FORMAT_PVRTC_SPEC_VERSION = 1;
  VK_IMG_FORMAT_PVRTC_EXTENSION_NAME = 'VK_IMG_format_pvrtc';
  VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION = 1;
  VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = 'VK_NV_external_memory_capabilities';
  VK_NV_EXTERNAL_MEMORY_SPEC_VERSION = 1;
  VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME = 'VK_NV_external_memory';
  VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION = 1;
  VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME = 'VK_NV_external_memory_win32';
  VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION = 1;
  VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME = 'VK_NV_win32_keyed_mutex';
  VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION = 1;
  VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME = 'VK_KHR_get_physical_device_properties2';
  VK_KHX_DEVICE_GROUP_SPEC_VERSION = 1;
  VK_KHX_DEVICE_GROUP_EXTENSION_NAME = 'VK_KHX_device_group';
  VK_EXT_VALIDATION_FLAGS_SPEC_VERSION = 1;
  VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME = 'VK_EXT_validation_flags';
  VK_NN_VI_SURFACE_SPEC_VERSION = 1;
  VK_NN_VI_SURFACE_EXTENSION_NAME = 'VK_NN_vi_surface';
  VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION = 1;
  VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME = 'VK_KHR_shader_draw_parameters';
  VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION = 1;
  VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME = 'VK_EXT_shader_subgroup_ballot';
  VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION = 1;
  VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME = 'VK_EXT_shader_subgroup_vote';
  VK_ARM_EXTENSION_01_SPEC_VERSION = 0;
  VK_ARM_EXTENSION_01_EXTENSION_NAME = 'VK_ARM_extension_01';
  VK_ARM_EXTENSION_02_SPEC_VERSION = 0;
  VK_ARM_EXTENSION_02_EXTENSION_NAME = 'VK_ARM_extension_02';
  VK_IMG_EXTENSION_69_SPEC_VERSION = 0;
  VK_IMG_EXTENSION_69_EXTENSION_NAME = 'VK_IMG_extension_69';
  VK_KHR_MAINTENANCE1_SPEC_VERSION = 1;
  VK_KHR_MAINTENANCE1_EXTENSION_NAME = 'VK_KHR_maintenance1';
  VK_KHX_DEVICE_GROUP_CREATION_SPEC_VERSION = 1;
  VK_KHX_DEVICE_GROUP_CREATION_EXTENSION_NAME = 'VK_KHX_device_group_creation';
  VK_KHX_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION = 1;
  VK_KHX_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = 'VK_KHX_external_memory_capabilities';
  VK_KHX_EXTERNAL_MEMORY_SPEC_VERSION = 1;
  VK_KHX_EXTERNAL_MEMORY_EXTENSION_NAME = 'VK_KHX_external_memory';
  VK_KHX_EXTERNAL_MEMORY_WIN32_SPEC_VERSION = 1;
  VK_KHX_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME = 'VK_KHX_external_memory_win32';
  VK_KHX_EXTERNAL_MEMORY_FD_SPEC_VERSION = 1;
  VK_KHX_EXTERNAL_MEMORY_FD_EXTENSION_NAME = 'VK_KHX_external_memory_fd';
  VK_KHX_WIN32_KEYED_MUTEX_SPEC_VERSION = 1;
  VK_KHX_WIN32_KEYED_MUTEX_EXTENSION_NAME = 'VK_KHX_win32_keyed_mutex';
  VK_KHX_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION = 1;
  VK_KHX_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME = 'VK_KHX_external_semaphore_capabilities';
  VK_KHX_EXTERNAL_SEMAPHORE_SPEC_VERSION = 1;
  VK_KHX_EXTERNAL_SEMAPHORE_EXTENSION_NAME = 'VK_KHX_external_semaphore';
  VK_KHX_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION = 1;
  VK_KHX_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME = 'VK_KHX_external_semaphore_win32';
  VK_KHX_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION = 1;
  VK_KHX_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME = 'VK_KHX_external_semaphore_fd';
  VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION = 1;
  VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME = 'VK_KHR_push_descriptor';
  VK_KHR_EXTENSION_82_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_82_EXTENSION_NAME = 'VK_KHR_extension_82';
  VK_KHR_EXTENSION_83_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_83_EXTENSION_NAME = 'VK_KHR_extension_83';
  VK_KHR_EXTENSION_84_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_84_EXTENSION_NAME = 'VK_KHR_extension_84';
  VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION = 1;
  VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME = 'VK_KHR_incremental_present';
  VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION = 1;
  VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME = 'VK_KHR_descriptor_update_template';
  VK_NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION = 1;
  VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME = 'VK_NVX_device_generated_commands';
  VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION = 1;
  VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME = 'VK_NV_clip_space_w_scaling';
  VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION = 1;
  VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME = 'VK_EXT_direct_mode_display';
  VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION = 1;
  VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME = 'VK_EXT_acquire_xlib_display';
  VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION = 1;
  VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME = 'VK_EXT_display_surface_counter';
  VK_EXT_DISPLAY_CONTROL_SPEC_VERSION = 1;
  VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME = 'VK_EXT_display_control';
  VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION = 1;
  VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME = 'VK_GOOGLE_display_timing';
  VK_KHR_EXTENSION_94_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_94_EXTENSION_NAME = 'VK_KHR_extension_94';
  VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION = 1;
  VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME = 'VK_NV_sample_mask_override_coverage';
  VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION = 1;
  VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME = 'VK_NV_geometry_shader_passthrough';
  VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION = 1;
  VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME = 'VK_NV_viewport_array2';
  VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION = 1;
  VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME = 'VK_NVX_multiview_per_view_attributes';
  VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION = 1;
  VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME = 'VK_NV_viewport_swizzle';
  VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION = 1;
  VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME = 'VK_EXT_discard_rectangles';
  VK_NV_EXTENSION_101_SPEC_VERSION = 0;
  VK_NV_EXTENSION_101_EXTENSION_NAME = 'VK_NV_extension_101';
  VK_NV_EXTENSION_102_SPEC_VERSION = 0;
  VK_NV_EXTENSION_102_EXTENSION_NAME = 'VK_NV_extension_102';
  VK_NV_EXTENSION_103_SPEC_VERSION = 0;
  VK_NV_EXTENSION_103_EXTENSION_NAME = 'VK_NV_extension_103';
  VK_NV_EXTENSION_104_SPEC_VERSION = 0;
  VK_NV_EXTENSION_104_EXTENSION_NAME = 'VK_NV_extension_104';
  VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION = 2;
  VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME = 'VK_EXT_swapchain_colorspace';
  VK_EXT_HDR_METADATA_SPEC_VERSION = 1;
  VK_EXT_HDR_METADATA_EXTENSION_NAME = 'VK_EXT_hdr_metadata';
  VK_IMG_EXTENSION_107_SPEC_VERSION = 0;
  VK_IMG_EXTENSION_107_EXTENSION_NAME = 'VK_IMG_extension_107';
  VK_IMG_EXTENSION_108_SPEC_VERSION = 0;
  VK_IMG_EXTENSION_108_EXTENSION_NAME = 'VK_IMG_extension_108';
  VK_IMG_EXTENSION_109_SPEC_VERSION = 0;
  VK_IMG_EXTENSION_109_EXTENSION_NAME = 'VK_IMG_extension_109';
  VK_IMG_EXTENSION_110_SPEC_VERSION = 0;
  VK_IMG_EXTENSION_110_EXTENSION_NAME = 'VK_IMG_extension_110';
  VK_IMG_EXTENSION_111_SPEC_VERSION = 0;
  VK_IMG_EXTENSION_111_EXTENSION_NAME = 'VK_IMG_extension_111';
  VK_KHR_EXTENSION_112_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_112_EXTENSION_NAME = 'VK_KHR_extension_112';
  VK_KHR_EXTENSION_113_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_113_EXTENSION_NAME = 'VK_KHR_extension_113';
  VK_KHR_EXTENSION_114_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_114_EXTENSION_NAME = 'VK_KHR_extension_114';
  VK_KHR_EXTENSION_115_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_115_EXTENSION_NAME = 'VK_KHR_extension_115';
  VK_KHR_EXTENSION_116_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_116_EXTENSION_NAME = 'VK_KHR_extension_116';
  VK_KHR_EXTENSION_117_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_117_EXTENSION_NAME = 'VK_KHR_extension_117';
  VK_KHR_EXTENSION_118_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_118_EXTENSION_NAME = 'VK_KHR_extension_118';
  VK_KHR_EXTENSION_119_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_119_EXTENSION_NAME = 'VK_KHR_extension_119';
  VK_KHR_EXTENSION_120_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_120_EXTENSION_NAME = 'VK_KHR_extension_120';
  VK_KHR_variable_pointers_SPEC_VERSION = 0;
  VK_KHR_variable_pointers_EXTENSION_NAME = 'VK_KHR_variable_pointers';
  VK_KHR_EXTENSION_122_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_122_EXTENSION_NAME = 'VK_KHR_extension_122';
  VK_MVK_IOS_SURFACE_SPEC_VERSION = 2;
  VK_MVK_IOS_SURFACE_EXTENSION_NAME = 'VK_MVK_ios_surface';
  VK_MVK_MACOS_SURFACE_SPEC_VERSION = 2;
  VK_MVK_MACOS_SURFACE_EXTENSION_NAME = 'VK_MVK_macos_surface';
  VK_MVK_MOLTENVK_SPEC_VERSION = 0;
  VK_MVK_MOLTENVK_EXTENSION_NAME = 'VK_MVK_moltenvk';
  VK_MESA_EXTENSION_126_SPEC_VERSION = 0;
  VK_MESA_EXTENSION_126_EXTENSION_NAME = 'VK_MESA_extension_126';
  VK_MESA_EXTENSION_127_SPEC_VERSION = 0;
  VK_MESA_EXTENSION_127_EXTENSION_NAME = 'VK_MESA_extension_127';
  VK_KHR_EXTENSION_128_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_128_EXTENSION_NAME = 'VK_KHR_extension_128';
  VK_KHR_EXTENSION_129_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_129_EXTENSION_NAME = 'VK_EXT_extension_129';
  VK_KHR_EXTENSION_130_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_130_EXTENSION_NAME = 'VK_KHR_extension_130';
  VK_KHR_EXTENSION_131_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_131_EXTENSION_NAME = 'VK_KHR_extension_131';
  VK_KHR_EXTENSION_132_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_132_EXTENSION_NAME = 'VK_KHR_extension_132';
  VK_AMD_EXTENSION_133_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_133_EXTENSION_NAME = 'VK_AMD_extension_133';
  VK_AMD_EXTENSION_134_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_134_EXTENSION_NAME = 'VK_AMD_extension_134';
  VK_AMD_EXTENSION_135_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_135_EXTENSION_NAME = 'VK_AMD_extension_135';
  VK_AMD_EXTENSION_136_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_136_EXTENSION_NAME = 'VK_AMD_extension_136';
  VK_AMD_EXTENSION_137_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_137_EXTENSION_NAME = 'VK_AMD_extension_137';
  VK_AMD_EXTENSION_138_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_138_EXTENSION_NAME = 'VK_AMD_extension_138';
  VK_AMD_EXTENSION_139_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_139_EXTENSION_NAME = 'VK_AMD_extension_139';
  VK_AMD_EXTENSION_140_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_140_EXTENSION_NAME = 'VK_AMD_extension_140';
  VK_AMD_EXTENSION_141_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_141_EXTENSION_NAME = 'VK_AMD_extension_141';
  VK_AMD_EXTENSION_142_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_142_EXTENSION_NAME = 'VK_AMD_extension_142';
  VK_AMD_EXTENSION_143_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_143_EXTENSION_NAME = 'VK_AMD_extension_143';
  VK_AMD_EXTENSION_144_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_144_EXTENSION_NAME = 'VK_AMD_extension_144';
  VK_KHR_relaxed_block_layout_SPEC_VERSION = 0;
  VK_KHR_relaxed_block_layout_EXTENSION_NAME = 'VK_KHR_relaxed_block_layout';
  VK_KHR_extension_146_SPEC_VERSION = 0;
  VK_KHR_extension_146_EXTENSION_NAME = 'VK_KHR_extension_146';
  VK_KHR_extension_147_SPEC_VERSION = 0;
  VK_KHR_extension_147_EXTENSION_NAME = 'VK_KHR_extension_147';
  VK_KHR_EXTENSION_148_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_148_EXTENSION_NAME = 'VK_EXT_extension_148';
  VK_NV_EXTENSION_149_SPEC_VERSION = 0;
  VK_NV_EXTENSION_149_EXTENSION_NAME = 'VK_NV_extension_149';
  VK_NV_EXTENSION_150_SPEC_VERSION = 0;
  VK_NV_EXTENSION_150_EXTENSION_NAME = 'VK_NV_extension_150';
  VK_NV_EXTENSION_151_SPEC_VERSION = 0;
  VK_NV_EXTENSION_151_EXTENSION_NAME = 'VK_NV_extension_151';
  VK_NV_EXTENSION_152_SPEC_VERSION = 0;
  VK_NV_EXTENSION_152_EXTENSION_NAME = 'VK_NV_extension_152';
  VK_NV_EXTENSION_153_SPEC_VERSION = 0;
  VK_NV_EXTENSION_153_EXTENSION_NAME = 'VK_NV_extension_153';

  type
    { Basic C types, pulled in via vk_platform.h }


  float = Single;
  Pfloat = ^float;
  uint8_t = Byte;
  uint32_t = Cardinal;
  Puint32_t = ^uint32_t;
  uint64_t = {$IFDEF DEFINE_UINT64_EQU_INT64} Int64{$ELSE} UInt64{$ENDIF};
  Puint64_t = ^uint64_t;
  int32_t = Longint;
  Pint32_t = ^int32_t;
  size_t = UintPtr;
  Psize_t = ^size_t;
  int = PtrInt;
  Pint = ^int;
  { SECTION: Vulkan type definitions }


  { WSI extensions }


  { The patch version here should never be set to anything other than 0 }


  { The patch version here should never be set to anything other than 0 }


  TVkHandle = PtrUInt;
  TVkNonDespatchableHandle = {$IFNDEF DEFINE_UINT64_EQU_INT64} UInt64{$ELSE} Int64{$ENDIF};
  TVkSampleMask = uint32_t;
  PVkSampleMask = ^TVkSampleMask;
  TVkBool32 = uint32_t;
  PVkBool32 = ^TVkBool32;
  TVkFlags = uint32_t;
  TVkDeviceSize = uint64_t;
  PVkDeviceSize = ^TVkDeviceSize;
  { Bitmask types }


  TVkFramebufferCreateFlags = TVkFlags;                      // creation flags
  TVkQueryPoolCreateFlags = TVkFlags;                        // creation flags
  TVkRenderPassCreateFlags = TVkFlags;                       // creation flags
  TVkSamplerCreateFlags = TVkFlags;                          // creation flags
  TVkPipelineLayoutCreateFlags = TVkFlags;                   // creation flags
  TVkPipelineCacheCreateFlags = TVkFlags;                    // creation flags
  TVkPipelineDepthStencilStateCreateFlags = TVkFlags;        // creation flags
  TVkPipelineDynamicStateCreateFlags = TVkFlags;             // creation flags
  TVkPipelineColorBlendStateCreateFlags = TVkFlags;          // creation flags
  TVkPipelineMultisampleStateCreateFlags = TVkFlags;         // creation flags
  TVkPipelineRasterizationStateCreateFlags = TVkFlags;       // creation flags
  TVkPipelineViewportStateCreateFlags = TVkFlags;            // creation flags
  TVkPipelineTessellationStateCreateFlags = TVkFlags;        // creation flags
  TVkPipelineInputAssemblyStateCreateFlags = TVkFlags;       // creation flags
  TVkPipelineVertexInputStateCreateFlags = TVkFlags;         // creation flags
  TVkPipelineShaderStageCreateFlags = TVkFlags;              // creation flags
  TVkDescriptorSetLayoutCreateFlags = set of TVkDescriptorSetLayoutCreateFlagBits_; // creation flags
  TVkBufferViewCreateFlags = TVkFlags;                       // creation flags
  TVkInstanceCreateFlags = TVkFlags;                         // creation flags
  TVkDeviceCreateFlags = TVkFlags;                           // creation flags
  TVkDeviceQueueCreateFlags = TVkFlags;                      // creation flags
  TVkQueueFlags = set of TVkQueueFlagBits_;                  // Queue capabilities
  TVkMemoryPropertyFlags = set of TVkMemoryPropertyFlagBits_; // Memory properties passed into vkAllocateMemory().
  TVkMemoryHeapFlags = set of TVkMemoryHeapFlagBits_;        // Memory heap flags
  TVkAccessFlags = set of TVkAccessFlagBits_;                // Memory access flags passed to barrier/dependency operations
  TVkBufferUsageFlags = set of TVkBufferUsageFlagBits_;      // Buffer usage flags
  TVkBufferCreateFlags = set of TVkBufferCreateFlagBits_;    // Buffer creation flags
  TVkShaderStageFlags = set of TVkShaderStageFlagBits_;      // Shader stage flags
  TVkImageUsageFlags = set of TVkImageUsageFlagBits_;        // Image usage flags
  TVkImageCreateFlags = set of TVkImageCreateFlagBits_;      // Image creation flags
  TVkImageViewCreateFlags = TVkFlags;                        // Image view creation flags (no bits yet)
  TVkPipelineCreateFlags = set of TVkPipelineCreateFlagBits_; // Pipeline creation flags
  TVkColorComponentFlags = set of TVkColorComponentFlagBits_; // Color component flags
  TVkFenceCreateFlags = set of TVkFenceCreateFlagBits_;      // Fence creation flags
  TVkSemaphoreCreateFlags = TVkFlags;                        // Semaphore creation flags
  TVkFormatFeatureFlags = set of TVkFormatFeatureFlagBits_;  // Format capability flags
  TVkQueryControlFlags = set of TVkQueryControlFlagBits_;    // Query control flags
  TVkQueryResultFlags = set of TVkQueryResultFlagBits_;      // Query result flags
  TVkShaderModuleCreateFlags = TVkFlags;                     // Shader module creation flags (no bits yet)
  TVkEventCreateFlags = TVkFlags;                            // Event creation flags  (no bits yet)
  TVkCommandPoolCreateFlags = set of TVkCommandPoolCreateFlagBits_; // Command pool creation flags
  TVkCommandPoolResetFlags = set of TVkCommandPoolResetFlagBits_; // Command pool reset flags
  TVkCommandBufferResetFlags = set of TVkCommandBufferResetFlagBits_; // Command buffer reset flags
  TVkCommandBufferUsageFlags = set of TVkCommandBufferUsageFlagBits_; // Command buffer usage flags
  TVkQueryPipelineStatisticFlags = set of TVkQueryPipelineStatisticFlagBits_; // Pipeline statistics flags
  TVkMemoryMapFlags = TVkFlags;                              // Memory mapping flags (no bits yet)
  TVkImageAspectFlags = set of TVkImageAspectFlagBits_;      // Bitmask of image aspects
  TVkSparseMemoryBindFlags = set of TVkSparseMemoryBindFlagBits_; // Sparse memory bind flags
  TVkSparseImageFormatFlags = set of TVkSparseImageFormatFlagBits_; // Sparse image memory requirements flags
  TVkSubpassDescriptionFlags = set of TVkSubpassDescriptionFlagBits_; // Subpass description flags
  TVkPipelineStageFlags = set of TVkPipelineStageFlagBits_;  // Pipeline stages
  PVkPipelineStageFlags = ^TVkPipelineStageFlags;
  TVkSampleCountFlags = set of TVkSampleCountFlagBits_;      // Pipeline stages
  TVkAttachmentDescriptionFlags = set of TVkAttachmentDescriptionFlagBits_; // Render pass attachment description flags
  TVkStencilFaceFlags = set of TVkStencilFaceFlagBits_;      // Stencil face flags
  TVkCullModeFlags = set of TVkCullModeFlagBits_;            // Cull mode flags
  TVkDescriptorPoolCreateFlags = set of TVkDescriptorPoolCreateFlagBits_; // Descriptor pool creation flags
  TVkDescriptorPoolResetFlags = TVkFlags;                    // Descriptor pool reset flags
  TVkDependencyFlags = set of TVkDependencyFlagBits_;        // Pipeline barrier and subpass dependency flags
  TVkIndirectCommandsLayoutUsageFlagsNVX = set of TVkIndirectCommandsLayoutUsageFlagBitsNVX_; // Device generated commands usage flags
  TVkObjectEntryUsageFlagsNVX = set of TVkObjectEntryUsageFlagBitsNVX_; // Object usage flags
  PVkObjectEntryUsageFlagsNVX = ^TVkObjectEntryUsageFlagsNVX;
  TVkDescriptorUpdateTemplateCreateFlagsKHR = TVkFlags;      // Descriptor update template creation flags
  { WSI extensions }


  TVkCompositeAlphaFlagsKHR = set of TVkCompositeAlphaFlagBitsKHR_;
  TVkDisplayPlaneAlphaFlagsKHR = set of TVkDisplayPlaneAlphaFlagBitsKHR_;
  TVkSurfaceTransformFlagsKHR = set of TVkSurfaceTransformFlagBitsKHR_;
  TVkSwapchainCreateFlagsKHR = set of TVkSwapchainCreateFlagBitsKHR_; // creation flags
  TVkDisplayModeCreateFlagsKHR = TVkFlags;                   // creation flags
  TVkDisplaySurfaceCreateFlagsKHR = TVkFlags;                // creation flags
  TVkAndroidSurfaceCreateFlagsKHR = TVkFlags;                // creation flags
  TVkMirSurfaceCreateFlagsKHR = TVkFlags;                    // creation flags
  TVkViSurfaceCreateFlagsNN = TVkFlags;                      // creation flags
  TVkWaylandSurfaceCreateFlagsKHR = TVkFlags;                // creation flags
  TVkWin32SurfaceCreateFlagsKHR = TVkFlags;                  // creation flags
  TVkXlibSurfaceCreateFlagsKHR = TVkFlags;                   // creation flags
  TVkXcbSurfaceCreateFlagsKHR = TVkFlags;                    // creation flags
  TVkIOSSurfaceCreateFlagsMVK = TVkFlags;                    // creation flags
  TVkMacOSSurfaceCreateFlagsMVK = TVkFlags;                  // creation flags
  TVkPeerMemoryFeatureFlagsKHX = set of TVkPeerMemoryFeatureFlagBitsKHX_; // Peer memory feature flags
  PVkPeerMemoryFeatureFlagsKHX = ^TVkPeerMemoryFeatureFlagsKHX;
  TVkMemoryAllocateFlagsKHX = set of TVkMemoryAllocateFlagBitsKHX_; // Memory allocation flags
  TVkDeviceGroupPresentModeFlagsKHX = set of TVkDeviceGroupPresentModeFlagBitsKHX_; // Device group present mode flags
  PVkDeviceGroupPresentModeFlagsKHX = ^TVkDeviceGroupPresentModeFlagsKHX;
  TVkDebugReportFlagsEXT = set of TVkDebugReportFlagBitsEXT_;
  TVkCommandPoolTrimFlagsKHR = TVkFlags;
  TVkExternalMemoryHandleTypeFlagsNV = set of TVkExternalMemoryHandleTypeFlagBitsNV_;
  TVkExternalMemoryFeatureFlagsNV = set of TVkExternalMemoryFeatureFlagBitsNV_;
  TVkExternalMemoryHandleTypeFlagsKHX = set of TVkExternalMemoryHandleTypeFlagBitsKHX_;
  TVkExternalMemoryFeatureFlagsKHX = set of TVkExternalMemoryFeatureFlagBitsKHX_;
  TVkExternalSemaphoreHandleTypeFlagsKHX = set of TVkExternalSemaphoreHandleTypeFlagBitsKHX_;
  TVkExternalSemaphoreFeatureFlagsKHX = set of TVkExternalSemaphoreFeatureFlagBitsKHX_;
  TVkSurfaceCounterFlagsEXT = set of TVkSurfaceCounterFlagBitsEXT_;
  TVkPipelineViewportSwizzleStateCreateFlagsNV = TVkFlags;   // creation flags (no bits yet)
  TVkPipelineDiscardRectangleStateCreateFlagsEXT = TVkFlags; // creation flags (no bits yet)
  { Types which can be void pointers or class pointers, selected at compile time }


  TVkInstance = TVkHandle;
  PVkInstance = ^TVkInstance;
  TVkPhysicalDevice = TVkHandle;
  PVkPhysicalDevice = ^TVkPhysicalDevice;
  TVkDevice = TVkHandle;
  PVkDevice = ^TVkDevice;
  TVkQueue = TVkHandle;
  PVkQueue = ^TVkQueue;
  TVkCommandBuffer = TVkHandle;
  PVkCommandBuffer = ^TVkCommandBuffer;
  TVkDeviceMemory = TVkNonDespatchableHandle;
  PVkDeviceMemory = ^TVkDeviceMemory;
  TVkCommandPool = TVkNonDespatchableHandle;
  PVkCommandPool = ^TVkCommandPool;
  TVkBuffer = TVkNonDespatchableHandle;
  PVkBuffer = ^TVkBuffer;
  TVkBufferView = TVkNonDespatchableHandle;
  PVkBufferView = ^TVkBufferView;
  TVkImage = TVkNonDespatchableHandle;
  PVkImage = ^TVkImage;
  TVkImageView = TVkNonDespatchableHandle;
  PVkImageView = ^TVkImageView;
  TVkShaderModule = TVkNonDespatchableHandle;
  PVkShaderModule = ^TVkShaderModule;
  TVkPipeline = TVkNonDespatchableHandle;
  PVkPipeline = ^TVkPipeline;
  TVkPipelineLayout = TVkNonDespatchableHandle;
  PVkPipelineLayout = ^TVkPipelineLayout;
  TVkSampler = TVkNonDespatchableHandle;
  PVkSampler = ^TVkSampler;
  TVkDescriptorSet = TVkNonDespatchableHandle;
  PVkDescriptorSet = ^TVkDescriptorSet;
  TVkDescriptorSetLayout = TVkNonDespatchableHandle;
  PVkDescriptorSetLayout = ^TVkDescriptorSetLayout;
  TVkDescriptorPool = TVkNonDespatchableHandle;
  PVkDescriptorPool = ^TVkDescriptorPool;
  TVkFence = TVkNonDespatchableHandle;
  PVkFence = ^TVkFence;
  TVkSemaphore = TVkNonDespatchableHandle;
  PVkSemaphore = ^TVkSemaphore;
  TVkEvent = TVkNonDespatchableHandle;
  PVkEvent = ^TVkEvent;
  TVkQueryPool = TVkNonDespatchableHandle;
  PVkQueryPool = ^TVkQueryPool;
  TVkFramebuffer = TVkNonDespatchableHandle;
  PVkFramebuffer = ^TVkFramebuffer;
  TVkRenderPass = TVkNonDespatchableHandle;
  PVkRenderPass = ^TVkRenderPass;
  TVkPipelineCache = TVkNonDespatchableHandle;
  PVkPipelineCache = ^TVkPipelineCache;
  TVkObjectTableNVX = TVkNonDespatchableHandle;
  PVkObjectTableNVX = ^TVkObjectTableNVX;
  TVkIndirectCommandsLayoutNVX = TVkNonDespatchableHandle;
  PVkIndirectCommandsLayoutNVX = ^TVkIndirectCommandsLayoutNVX;
  TVkDescriptorUpdateTemplateKHR = TVkNonDespatchableHandle;
  PVkDescriptorUpdateTemplateKHR = ^TVkDescriptorUpdateTemplateKHR;
  { WSI extensions }


  TVkDisplayKHR = TVkNonDespatchableHandle;
  PVkDisplayKHR = ^TVkDisplayKHR;
  TVkDisplayModeKHR = TVkNonDespatchableHandle;
  PVkDisplayModeKHR = ^TVkDisplayModeKHR;
  TVkSurfaceKHR = TVkNonDespatchableHandle;
  PVkSurfaceKHR = ^TVkSurfaceKHR;
  TVkSwapchainKHR = TVkNonDespatchableHandle;
  PVkSwapchainKHR = ^TVkSwapchainKHR;
  TVkDebugReportCallbackEXT = TVkNonDespatchableHandle;
  PVkDebugReportCallbackEXT = ^TVkDebugReportCallbackEXT;
  Tfloat_0_3 = array[0..3] of float;

  TvkExtension = (
    VK_KHR_surface, 
    VK_KHR_swapchain, 
    VK_KHR_display, 
    VK_KHR_display_swapchain, 
    VK_KHR_xlib_surface, 
    VK_KHR_xcb_surface, 
    VK_KHR_wayland_surface, 
    VK_KHR_mir_surface, 
    VK_KHR_android_surface, 
    VK_KHR_win32_surface, 
    VK_ANDROID_native_buffer, 
    VK_EXT_debug_report, 
    VK_NV_glsl_shader, 
    VK_NV_extension_1, 
    VK_KHR_sampler_mirror_clamp_to_edge, 
    VK_IMG_filter_cubic, 
    VK_AMD_extension_17, 
    VK_AMD_extension_18, 
    VK_AMD_rasterization_order, 
    VK_AMD_extension_20, 
    VK_AMD_shader_trinary_minmax, 
    VK_AMD_shader_explicit_vertex_parameter, 
    VK_EXT_debug_marker, 
    VK_AMD_extension_24, 
    VK_AMD_extension_25, 
    VK_AMD_gcn_shader, 
    VK_NV_dedicated_allocation, 
    VK_EXT_extension_28, 
    VK_NVX_extension_29, 
    VK_NVX_extension_30, 
    VK_NVX_extension_31, 
    VK_AMD_extension_32, 
    VK_AMD_extension_33, 
    VK_AMD_draw_indirect_count, 
    VK_AMD_extension_35, 
    VK_AMD_negative_viewport_height, 
    VK_AMD_gpu_shader_half_float, 
    VK_AMD_shader_ballot, 
    VK_AMD_extension_39, 
    VK_AMD_extension_40, 
    VK_AMD_extension_41, 
    VK_AMD_extension_42, 
    VK_AMD_extension_43, 
    VK_AMD_extension_44, 
    VK_AMD_extension_45, 
    VK_AMD_extension_46, 
    VK_AMD_extension_47, 
    VK_NVX_extension_48, 
    VK_GOOGLE_extension_49, 
    VK_GOOGLE_extension_50, 
    VK_NVX_extension_51, 
    VK_NVX_extension_52, 
    VK_NV_extension_53, 
    VK_KHX_multiview, 
    VK_IMG_format_pvrtc, 
    VK_NV_external_memory_capabilities, 
    VK_NV_external_memory, 
    VK_NV_external_memory_win32, 
    VK_NV_win32_keyed_mutex, 
    VK_KHR_get_physical_device_properties2, 
    VK_KHX_device_group, 
    VK_EXT_validation_flags, 
    VK_NN_vi_surface, 
    VK_KHR_shader_draw_parameters, 
    VK_EXT_shader_subgroup_ballot, 
    VK_EXT_shader_subgroup_vote, 
    VK_ARM_extension_01, 
    VK_ARM_extension_02, 
    VK_IMG_extension_69, 
    VK_KHR_maintenance1, 
    VK_KHX_device_group_creation, 
    VK_KHX_external_memory_capabilities, 
    VK_KHX_external_memory, 
    VK_KHX_external_memory_win32, 
    VK_KHX_external_memory_fd, 
    VK_KHX_win32_keyed_mutex, 
    VK_KHX_external_semaphore_capabilities, 
    VK_KHX_external_semaphore, 
    VK_KHX_external_semaphore_win32, 
    VK_KHX_external_semaphore_fd, 
    VK_KHR_push_descriptor, 
    VK_KHR_extension_82, 
    VK_KHR_extension_83, 
    VK_KHR_extension_84, 
    VK_KHR_incremental_present, 
    VK_KHR_descriptor_update_template, 
    VK_NVX_device_generated_commands, 
    VK_NV_clip_space_w_scaling, 
    VK_EXT_direct_mode_display, 
    VK_EXT_acquire_xlib_display, 
    VK_EXT_display_surface_counter, 
    VK_EXT_display_control, 
    VK_GOOGLE_display_timing, 
    VK_KHR_extension_94, 
    VK_NV_sample_mask_override_coverage, 
    VK_NV_geometry_shader_passthrough, 
    VK_NV_viewport_array2, 
    VK_NVX_multiview_per_view_attributes, 
    VK_NV_viewport_swizzle, 
    VK_EXT_discard_rectangles, 
    VK_NV_extension_101, 
    VK_NV_extension_102, 
    VK_NV_extension_103, 
    VK_NV_extension_104, 
    VK_EXT_swapchain_colorspace, 
    VK_EXT_hdr_metadata, 
    VK_IMG_extension_107, 
    VK_IMG_extension_108, 
    VK_IMG_extension_109, 
    VK_IMG_extension_110, 
    VK_IMG_extension_111, 
    VK_KHR_extension_112, 
    VK_KHR_extension_113, 
    VK_KHR_extension_114, 
    VK_KHR_extension_115, 
    VK_KHR_extension_116, 
    VK_KHR_extension_117, 
    VK_KHR_extension_118, 
    VK_KHR_extension_119, 
    VK_KHR_extension_120, 
    VK_KHR_variable_pointers, 
    VK_KHR_extension_122, 
    VK_MVK_ios_surface, 
    VK_MVK_macos_surface, 
    VK_MVK_moltenvk, 
    VK_MESA_extension_126, 
    VK_MESA_extension_127, 
    VK_KHR_extension_128, 
    VK_EXT_extension_129, 
    VK_KHR_extension_130, 
    VK_KHR_extension_131, 
    VK_KHR_extension_132, 
    VK_AMD_extension_133, 
    VK_AMD_extension_134, 
    VK_AMD_extension_135, 
    VK_AMD_extension_136, 
    VK_AMD_extension_137, 
    VK_AMD_extension_138, 
    VK_AMD_extension_139, 
    VK_AMD_extension_140, 
    VK_AMD_extension_141, 
    VK_AMD_extension_142, 
    VK_AMD_extension_143, 
    VK_AMD_extension_144, 
    VK_KHR_relaxed_block_layout, 
    VK_KHR_extension_146, 
    VK_KHR_extension_147, 
    VK_EXT_extension_148, 
    VK_NV_extension_149, 
    VK_NV_extension_150, 
    VK_NV_extension_151, 
    VK_NV_extension_152, 
    VK_NV_extension_153
  );

  TvkExtensions = set of TvkExtension;

  const
  vkExtension_Names: array[TvkExtension] of String = (
    'VK_KHR_surface', 
    'VK_KHR_swapchain', 
    'VK_KHR_display', 
    'VK_KHR_display_swapchain', 
    'VK_KHR_xlib_surface', 
    'VK_KHR_xcb_surface', 
    'VK_KHR_wayland_surface', 
    'VK_KHR_mir_surface', 
    'VK_KHR_android_surface', 
    'VK_KHR_win32_surface', 
    'VK_ANDROID_native_buffer', 
    'VK_EXT_debug_report', 
    'VK_NV_glsl_shader', 
    'VK_NV_extension_1', 
    'VK_KHR_sampler_mirror_clamp_to_edge', 
    'VK_IMG_filter_cubic', 
    'VK_AMD_extension_17', 
    'VK_AMD_extension_18', 
    'VK_AMD_rasterization_order', 
    'VK_AMD_extension_20', 
    'VK_AMD_shader_trinary_minmax', 
    'VK_AMD_shader_explicit_vertex_parameter', 
    'VK_EXT_debug_marker', 
    'VK_AMD_extension_24', 
    'VK_AMD_extension_25', 
    'VK_AMD_gcn_shader', 
    'VK_NV_dedicated_allocation', 
    'VK_EXT_extension_28', 
    'VK_NVX_extension_29', 
    'VK_NVX_extension_30', 
    'VK_NVX_extension_31', 
    'VK_AMD_extension_32', 
    'VK_AMD_extension_33', 
    'VK_AMD_draw_indirect_count', 
    'VK_AMD_extension_35', 
    'VK_AMD_negative_viewport_height', 
    'VK_AMD_gpu_shader_half_float', 
    'VK_AMD_shader_ballot', 
    'VK_AMD_extension_39', 
    'VK_AMD_extension_40', 
    'VK_AMD_extension_41', 
    'VK_AMD_extension_42', 
    'VK_AMD_extension_43', 
    'VK_AMD_extension_44', 
    'VK_AMD_extension_45', 
    'VK_AMD_extension_46', 
    'VK_AMD_extension_47', 
    'VK_NVX_extension_48', 
    'VK_GOOGLE_extension_49', 
    'VK_GOOGLE_extension_50', 
    'VK_NVX_extension_51', 
    'VK_NVX_extension_52', 
    'VK_NV_extension_53', 
    'VK_KHX_multiview', 
    'VK_IMG_format_pvrtc', 
    'VK_NV_external_memory_capabilities', 
    'VK_NV_external_memory', 
    'VK_NV_external_memory_win32', 
    'VK_NV_win32_keyed_mutex', 
    'VK_KHR_get_physical_device_properties2', 
    'VK_KHX_device_group', 
    'VK_EXT_validation_flags', 
    'VK_NN_vi_surface', 
    'VK_KHR_shader_draw_parameters', 
    'VK_EXT_shader_subgroup_ballot', 
    'VK_EXT_shader_subgroup_vote', 
    'VK_ARM_extension_01', 
    'VK_ARM_extension_02', 
    'VK_IMG_extension_69', 
    'VK_KHR_maintenance1', 
    'VK_KHX_device_group_creation', 
    'VK_KHX_external_memory_capabilities', 
    'VK_KHX_external_memory', 
    'VK_KHX_external_memory_win32', 
    'VK_KHX_external_memory_fd', 
    'VK_KHX_win32_keyed_mutex', 
    'VK_KHX_external_semaphore_capabilities', 
    'VK_KHX_external_semaphore', 
    'VK_KHX_external_semaphore_win32', 
    'VK_KHX_external_semaphore_fd', 
    'VK_KHR_push_descriptor', 
    'VK_KHR_extension_82', 
    'VK_KHR_extension_83', 
    'VK_KHR_extension_84', 
    'VK_KHR_incremental_present', 
    'VK_KHR_descriptor_update_template', 
    'VK_NVX_device_generated_commands', 
    'VK_NV_clip_space_w_scaling', 
    'VK_EXT_direct_mode_display', 
    'VK_EXT_acquire_xlib_display', 
    'VK_EXT_display_surface_counter', 
    'VK_EXT_display_control', 
    'VK_GOOGLE_display_timing', 
    'VK_KHR_extension_94', 
    'VK_NV_sample_mask_override_coverage', 
    'VK_NV_geometry_shader_passthrough', 
    'VK_NV_viewport_array2', 
    'VK_NVX_multiview_per_view_attributes', 
    'VK_NV_viewport_swizzle', 
    'VK_EXT_discard_rectangles', 
    'VK_NV_extension_101', 
    'VK_NV_extension_102', 
    'VK_NV_extension_103', 
    'VK_NV_extension_104', 
    'VK_EXT_swapchain_colorspace', 
    'VK_EXT_hdr_metadata', 
    'VK_IMG_extension_107', 
    'VK_IMG_extension_108', 
    'VK_IMG_extension_109', 
    'VK_IMG_extension_110', 
    'VK_IMG_extension_111', 
    'VK_KHR_extension_112', 
    'VK_KHR_extension_113', 
    'VK_KHR_extension_114', 
    'VK_KHR_extension_115', 
    'VK_KHR_extension_116', 
    'VK_KHR_extension_117', 
    'VK_KHR_extension_118', 
    'VK_KHR_extension_119', 
    'VK_KHR_extension_120', 
    'VK_KHR_variable_pointers', 
    'VK_KHR_extension_122', 
    'VK_MVK_ios_surface', 
    'VK_MVK_macos_surface', 
    'VK_MVK_moltenvk', 
    'VK_MESA_extension_126', 
    'VK_MESA_extension_127', 
    'VK_KHR_extension_128', 
    'VK_EXT_extension_129', 
    'VK_KHR_extension_130', 
    'VK_KHR_extension_131', 
    'VK_KHR_extension_132', 
    'VK_AMD_extension_133', 
    'VK_AMD_extension_134', 
    'VK_AMD_extension_135', 
    'VK_AMD_extension_136', 
    'VK_AMD_extension_137', 
    'VK_AMD_extension_138', 
    'VK_AMD_extension_139', 
    'VK_AMD_extension_140', 
    'VK_AMD_extension_141', 
    'VK_AMD_extension_142', 
    'VK_AMD_extension_143', 
    'VK_AMD_extension_144', 
    'VK_KHR_relaxed_block_layout', 
    'VK_KHR_extension_146', 
    'VK_KHR_extension_147', 
    'VK_EXT_extension_148', 
    'VK_NV_extension_149', 
    'VK_NV_extension_150', 
    'VK_NV_extension_151', 
    'VK_NV_extension_152', 
    'VK_NV_extension_153'
  );

type

    { Types generated from corresponding <enums> tags below }


  { WSI extensions }


  { The PFN_vk*Function types are used by VkAllocationCallbacks below }


  TPFN_vkInternalAllocationNotification = procedure(
    pUserData: Pointer;
    size: size_t;
    allocationType: TVkInternalAllocationType;
    allocationScope: TVkSystemAllocationScope
  );

  TPFN_vkInternalFreeNotification = procedure(
    pUserData: Pointer;
    size: size_t;
    allocationType: TVkInternalAllocationType;
    allocationScope: TVkSystemAllocationScope
  );

  TPFN_vkReallocationFunction = function(
    pUserData: Pointer;
    pOriginal: Pointer;
    size: size_t;
    alignment: size_t;
    allocationScope: TVkSystemAllocationScope
  ): Pointer;

  TPFN_vkAllocationFunction = function(
    pUserData: Pointer;
    size: size_t;
    alignment: size_t;
    allocationScope: TVkSystemAllocationScope
  ): Pointer;

  TPFN_vkFreeFunction = procedure(
    pUserData: Pointer;
    pMemory: Pointer
  );

  { The PFN_vkVoidFunction type are used by VkGet*ProcAddr below }


  TPFN_vkVoidFunction = procedure(
  );

  { The PFN_vkDebugReportCallbackEXT type are used by the DEBUG_REPORT extension }


  TPFN_vkDebugReportCallbackEXT = function(
    flags: TVkDebugReportFlagsEXT;
    objectType: TVkDebugReportObjectTypeEXT;
    object_: uint64_t;
    location: size_t;
    messageCode: int32_t;
    pLayerPrefix: Pchar;
    pMessage: Pchar;
    pUserData: Pointer
  ): TVkBool32;


    { Struct types }


  TVkOffset2D = record
    x: int32_t;
    y: int32_t;
  end;

  TVkOffset3D = record
    x: int32_t;
    y: int32_t;
    z: int32_t;
  end;

  TVkExtent2D = record
    width: uint32_t;
    height: uint32_t;
  end;
  PVkExtent2D = ^TVkExtent2D;

  TVkExtent3D = record
    width: uint32_t;
    height: uint32_t;
    depth: uint32_t;
  end;

  TVkViewport = record
    x: float;
    y: float;
    width: float;
    height: float;
    minDepth: float;
    maxDepth: float;
  end;
  PVkViewport = ^TVkViewport;

  TVkRect2D = record
    offset: TVkOffset2D;
    extent: TVkExtent2D;
  end;
  PVkRect2D = ^TVkRect2D;

  TVkRect3D = record
    offset: TVkOffset3D;
    extent: TVkExtent3D;
  end;

  TVkClearRect = record
    rect: TVkRect2D;
    baseArrayLayer: uint32_t;
    layerCount: uint32_t;
  end;
  PVkClearRect = ^TVkClearRect;

  TVkComponentMapping = record
    r: TVkComponentSwizzle;
    g: TVkComponentSwizzle;
    b: TVkComponentSwizzle;
    a: TVkComponentSwizzle;
  end;

  TVkPhysicalDeviceLimits = record
    maxImageDimension1D: uint32_t;
    maxImageDimension2D: uint32_t;
    maxImageDimension3D: uint32_t;
    maxImageDimensionCube: uint32_t;
    maxImageArrayLayers: uint32_t;
    maxTexelBufferElements: uint32_t;
    maxUniformBufferRange: uint32_t;
    maxStorageBufferRange: uint32_t;
    maxPushConstantsSize: uint32_t;
    maxMemoryAllocationCount: uint32_t;
    maxSamplerAllocationCount: uint32_t;
    bufferImageGranularity: TVkDeviceSize;
    sparseAddressSpaceSize: TVkDeviceSize;
    maxBoundDescriptorSets: uint32_t;
    maxPerStageDescriptorSamplers: uint32_t;
    maxPerStageDescriptorUniformBuffers: uint32_t;
    maxPerStageDescriptorStorageBuffers: uint32_t;
    maxPerStageDescriptorSampledImages: uint32_t;
    maxPerStageDescriptorStorageImages: uint32_t;
    maxPerStageDescriptorInputAttachments: uint32_t;
    maxPerStageResources: uint32_t;
    maxDescriptorSetSamplers: uint32_t;
    maxDescriptorSetUniformBuffers: uint32_t;
    maxDescriptorSetUniformBuffersDynamic: uint32_t;
    maxDescriptorSetStorageBuffers: uint32_t;
    maxDescriptorSetStorageBuffersDynamic: uint32_t;
    maxDescriptorSetSampledImages: uint32_t;
    maxDescriptorSetStorageImages: uint32_t;
    maxDescriptorSetInputAttachments: uint32_t;
    maxVertexInputAttributes: uint32_t;
    maxVertexInputBindings: uint32_t;
    maxVertexInputAttributeOffset: uint32_t;
    maxVertexInputBindingStride: uint32_t;
    maxVertexOutputComponents: uint32_t;
    maxTessellationGenerationLevel: uint32_t;
    maxTessellationPatchSize: uint32_t;
    maxTessellationControlPerVertexInputComponents: uint32_t;
    maxTessellationControlPerVertexOutputComponents: uint32_t;
    maxTessellationControlPerPatchOutputComponents: uint32_t;
    maxTessellationControlTotalOutputComponents: uint32_t;
    maxTessellationEvaluationInputComponents: uint32_t;
    maxTessellationEvaluationOutputComponents: uint32_t;
    maxGeometryShaderInvocations: uint32_t;
    maxGeometryInputComponents: uint32_t;
    maxGeometryOutputComponents: uint32_t;
    maxGeometryOutputVertices: uint32_t;
    maxGeometryTotalOutputComponents: uint32_t;
    maxFragmentInputComponents: uint32_t;
    maxFragmentOutputAttachments: uint32_t;
    maxFragmentDualSrcAttachments: uint32_t;
    maxFragmentCombinedOutputResources: uint32_t;
    maxComputeSharedMemorySize: uint32_t;
    maxComputeWorkGroupCount: array[0..2] of uint32_t;
    maxComputeWorkGroupInvocations: uint32_t;
    maxComputeWorkGroupSize: array[0..2] of uint32_t;
    subPixelPrecisionBits: uint32_t;
    subTexelPrecisionBits: uint32_t;
    mipmapPrecisionBits: uint32_t;
    maxDrawIndexedIndexValue: uint32_t;
    maxDrawIndirectCount: uint32_t;
    maxSamplerLodBias: float;
    maxSamplerAnisotropy: float;
    maxViewports: uint32_t;
    maxViewportDimensions: array[0..1] of uint32_t;
    viewportBoundsRange: array[0..1] of float;
    viewportSubPixelBits: uint32_t;
    minMemoryMapAlignment: size_t;
    minTexelBufferOffsetAlignment: TVkDeviceSize;
    minUniformBufferOffsetAlignment: TVkDeviceSize;
    minStorageBufferOffsetAlignment: TVkDeviceSize;
    minTexelOffset: int32_t;
    maxTexelOffset: uint32_t;
    minTexelGatherOffset: int32_t;
    maxTexelGatherOffset: uint32_t;
    minInterpolationOffset: float;
    maxInterpolationOffset: float;
    subPixelInterpolationOffsetBits: uint32_t;
    maxFramebufferWidth: uint32_t;
    maxFramebufferHeight: uint32_t;
    maxFramebufferLayers: uint32_t;
    framebufferColorSampleCounts: TVkSampleCountFlags;
    framebufferDepthSampleCounts: TVkSampleCountFlags;
    framebufferStencilSampleCounts: TVkSampleCountFlags;
    framebufferNoAttachmentsSampleCounts: TVkSampleCountFlags;
    maxColorAttachments: uint32_t;
    sampledImageColorSampleCounts: TVkSampleCountFlags;
    sampledImageIntegerSampleCounts: TVkSampleCountFlags;
    sampledImageDepthSampleCounts: TVkSampleCountFlags;
    sampledImageStencilSampleCounts: TVkSampleCountFlags;
    storageImageSampleCounts: TVkSampleCountFlags;
    maxSampleMaskWords: uint32_t;
    timestampComputeAndGraphics: TVkBool32;
    timestampPeriod: float;
    maxClipDistances: uint32_t;
    maxCullDistances: uint32_t;
    maxCombinedClipAndCullDistances: uint32_t;
    discreteQueuePriorities: uint32_t;
    pointSizeRange: array[0..1] of float;
    lineWidthRange: array[0..1] of float;
    pointSizeGranularity: float;
    lineWidthGranularity: float;
    strictLines: TVkBool32;
    standardSampleLocations: TVkBool32;
    optimalBufferCopyOffsetAlignment: TVkDeviceSize;
    optimalBufferCopyRowPitchAlignment: TVkDeviceSize;
    nonCoherentAtomSize: TVkDeviceSize;
  end;

  TVkPhysicalDeviceSparseProperties = record
    residencyStandard2DBlockShape: TVkBool32;
    residencyStandard2DMultisampleBlockShape: TVkBool32;
    residencyStandard3DBlockShape: TVkBool32;
    residencyAlignedMipSize: TVkBool32;
    residencyNonResidentStrict: TVkBool32;
  end;

  TVkPhysicalDeviceProperties = record
    apiVersion: uint32_t;
    driverVersion: uint32_t;
    vendorID: uint32_t;
    deviceID: uint32_t;
    deviceType: TVkPhysicalDeviceType;
    deviceName: array[0..(VK_MAX_PHYSICAL_DEVICE_NAME_SIZE - 1)] of char;
    pipelineCacheUUID: array[0..(VK_UUID_SIZE - 1)] of uint8_t;
    limits: TVkPhysicalDeviceLimits;
    sparseProperties: TVkPhysicalDeviceSparseProperties;
  end;
  PVkPhysicalDeviceProperties = ^TVkPhysicalDeviceProperties;

  TVkExtensionProperties = record
    extensionName: array[0..(VK_MAX_EXTENSION_NAME_SIZE - 1)] of char;
    specVersion: uint32_t;
  end;
  PVkExtensionProperties = ^TVkExtensionProperties;

  TVkLayerProperties = record
    layerName: array[0..(VK_MAX_EXTENSION_NAME_SIZE - 1)] of char;
    specVersion: uint32_t;
    implementationVersion: uint32_t;
    description: array[0..(VK_MAX_DESCRIPTION_SIZE - 1)] of char;
  end;
  PVkLayerProperties = ^TVkLayerProperties;

  TVkApplicationInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    pApplicationName: Pchar;
    applicationVersion: uint32_t;
    pEngineName: Pchar;
    engineVersion: uint32_t;
    apiVersion: uint32_t;
  end;
  PVkApplicationInfo = ^TVkApplicationInfo;

  TVkAllocationCallbacks = record
    pUserData: Pointer;
    pfnAllocation: TPFN_vkAllocationFunction;
    pfnReallocation: TPFN_vkReallocationFunction;
    pfnFree: TPFN_vkFreeFunction;
    pfnInternalAllocation: TPFN_vkInternalAllocationNotification;
    pfnInternalFree: TPFN_vkInternalFreeNotification;
  end;
  PVkAllocationCallbacks = ^TVkAllocationCallbacks;

  TVkDeviceQueueCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkDeviceQueueCreateFlags;
    queueFamilyIndex: uint32_t;
    queueCount: uint32_t;
    pQueuePriorities: Pfloat;
  end;
  PVkDeviceQueueCreateInfo = ^TVkDeviceQueueCreateInfo;

  TVkPhysicalDeviceFeatures = record
    robustBufferAccess: TVkBool32;
    fullDrawIndexUint32: TVkBool32;
    imageCubeArray: TVkBool32;
    independentBlend: TVkBool32;
    geometryShader: TVkBool32;
    tessellationShader: TVkBool32;
    sampleRateShading: TVkBool32;
    dualSrcBlend: TVkBool32;
    logicOp: TVkBool32;
    multiDrawIndirect: TVkBool32;
    drawIndirectFirstInstance: TVkBool32;
    depthClamp: TVkBool32;
    depthBiasClamp: TVkBool32;
    fillModeNonSolid: TVkBool32;
    depthBounds: TVkBool32;
    wideLines: TVkBool32;
    largePoints: TVkBool32;
    alphaToOne: TVkBool32;
    multiViewport: TVkBool32;
    samplerAnisotropy: TVkBool32;
    textureCompressionETC2: TVkBool32;
    textureCompressionASTC_LDR: TVkBool32;
    textureCompressionBC: TVkBool32;
    occlusionQueryPrecise: TVkBool32;
    pipelineStatisticsQuery: TVkBool32;
    vertexPipelineStoresAndAtomics: TVkBool32;
    fragmentStoresAndAtomics: TVkBool32;
    shaderTessellationAndGeometryPointSize: TVkBool32;
    shaderImageGatherExtended: TVkBool32;
    shaderStorageImageExtendedFormats: TVkBool32;
    shaderStorageImageMultisample: TVkBool32;
    shaderStorageImageReadWithoutFormat: TVkBool32;
    shaderStorageImageWriteWithoutFormat: TVkBool32;
    shaderUniformBufferArrayDynamicIndexing: TVkBool32;
    shaderSampledImageArrayDynamicIndexing: TVkBool32;
    shaderStorageBufferArrayDynamicIndexing: TVkBool32;
    shaderStorageImageArrayDynamicIndexing: TVkBool32;
    shaderClipDistance: TVkBool32;
    shaderCullDistance: TVkBool32;
    shaderFloat64: TVkBool32;
    shaderInt64: TVkBool32;
    shaderInt16: TVkBool32;
    shaderResourceResidency: TVkBool32;
    shaderResourceMinLod: TVkBool32;
    sparseBinding: TVkBool32;
    sparseResidencyBuffer: TVkBool32;
    sparseResidencyImage2D: TVkBool32;
    sparseResidencyImage3D: TVkBool32;
    sparseResidency2Samples: TVkBool32;
    sparseResidency4Samples: TVkBool32;
    sparseResidency8Samples: TVkBool32;
    sparseResidency16Samples: TVkBool32;
    sparseResidencyAliased: TVkBool32;
    variableMultisampleRate: TVkBool32;
    inheritedQueries: TVkBool32;
  end;
  PVkPhysicalDeviceFeatures = ^TVkPhysicalDeviceFeatures;
  TVkPhysicalDeviceFeatures_enum = (
    robustBufferAccess,
    fullDrawIndexUint32,
    imageCubeArray,
    independentBlend,
    geometryShader,
    tessellationShader,
    sampleRateShading,
    dualSrcBlend,
    logicOp,
    multiDrawIndirect,
    drawIndirectFirstInstance,
    depthClamp,
    depthBiasClamp,
    fillModeNonSolid,
    depthBounds,
    wideLines,
    largePoints,
    alphaToOne,
    multiViewport,
    samplerAnisotropy,
    textureCompressionETC2,
    textureCompressionASTC_LDR,
    textureCompressionBC,
    occlusionQueryPrecise,
    pipelineStatisticsQuery,
    vertexPipelineStoresAndAtomics,
    fragmentStoresAndAtomics,
    shaderTessellationAndGeometryPointSize,
    shaderImageGatherExtended,
    shaderStorageImageExtendedFormats,
    shaderStorageImageMultisample,
    shaderStorageImageReadWithoutFormat,
    shaderStorageImageWriteWithoutFormat,
    shaderUniformBufferArrayDynamicIndexing,
    shaderSampledImageArrayDynamicIndexing,
    shaderStorageBufferArrayDynamicIndexing,
    shaderStorageImageArrayDynamicIndexing,
    shaderClipDistance,
    shaderCullDistance,
    shaderFloat64,
    shaderInt64,
    shaderInt16,
    shaderResourceResidency,
    shaderResourceMinLod,
    sparseBinding,
    sparseResidencyBuffer,
    sparseResidencyImage2D,
    sparseResidencyImage3D,
    sparseResidency2Samples,
    sparseResidency4Samples,
    sparseResidency8Samples,
    sparseResidency16Samples,
    sparseResidencyAliased,
    variableMultisampleRate,
    inheritedQueries
  );

  TVkDeviceCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkDeviceCreateFlags;
    queueCreateInfoCount: uint32_t;
    pQueueCreateInfos: PVkDeviceQueueCreateInfo;
    enabledLayerCount: uint32_t;
    ppEnabledLayerNames: PPchar;
    enabledExtensionCount: uint32_t;
    ppEnabledExtensionNames: PPchar;
    pEnabledFeatures: PVkPhysicalDeviceFeatures;
  end;
  PVkDeviceCreateInfo = ^TVkDeviceCreateInfo;

  TVkInstanceCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkInstanceCreateFlags;
    pApplicationInfo: PVkApplicationInfo;
    enabledLayerCount: uint32_t;
    ppEnabledLayerNames: PPchar;
    enabledExtensionCount: uint32_t;
    ppEnabledExtensionNames: PPchar;
  end;
  PVkInstanceCreateInfo = ^TVkInstanceCreateInfo;

  TVkQueueFamilyProperties = record
    queueFlags: TVkQueueFlags;
    queueCount: uint32_t;
    timestampValidBits: uint32_t;
    minImageTransferGranularity: TVkExtent3D;
  end;
  PVkQueueFamilyProperties = ^TVkQueueFamilyProperties;

  TVkMemoryType = record
    propertyFlags: TVkMemoryPropertyFlags;
    heapIndex: uint32_t;
  end;

  TVkMemoryHeap = record
    size: TVkDeviceSize;
    flags: TVkMemoryHeapFlags;
  end;

  TVkPhysicalDeviceMemoryProperties = record
    memoryTypeCount: uint32_t;
    memoryTypes: array[0..(VK_MAX_MEMORY_TYPES - 1)] of TVkMemoryType;
    memoryHeapCount: uint32_t;
    memoryHeaps: array[0..(VK_MAX_MEMORY_HEAPS - 1)] of TVkMemoryHeap;
  end;
  PVkPhysicalDeviceMemoryProperties = ^TVkPhysicalDeviceMemoryProperties;

  TVkMemoryAllocateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    allocationSize: TVkDeviceSize;
    memoryTypeIndex: uint32_t;
  end;
  PVkMemoryAllocateInfo = ^TVkMemoryAllocateInfo;

  TVkMemoryRequirements = record
    size: TVkDeviceSize;
    alignment: TVkDeviceSize;
    memoryTypeBits: uint32_t;
  end;
  PVkMemoryRequirements = ^TVkMemoryRequirements;

  TVkSparseImageFormatProperties = record
    aspectMask: TVkImageAspectFlags;
    imageGranularity: TVkExtent3D;
    flags: TVkSparseImageFormatFlags;
  end;
  PVkSparseImageFormatProperties = ^TVkSparseImageFormatProperties;

  TVkSparseImageMemoryRequirements = record
    formatProperties: TVkSparseImageFormatProperties;
    imageMipTailFirstLod: uint32_t;
    imageMipTailSize: TVkDeviceSize;
    imageMipTailOffset: TVkDeviceSize;
    imageMipTailStride: TVkDeviceSize;
  end;
  PVkSparseImageMemoryRequirements = ^TVkSparseImageMemoryRequirements;

  TVkMappedMemoryRange = record
    sType: TVkStructureType;
    pNext: Pointer;
    memory: TVkDeviceMemory;
    offset: TVkDeviceSize;
    size: TVkDeviceSize;
  end;
  PVkMappedMemoryRange = ^TVkMappedMemoryRange;

  TVkFormatProperties = record
    linearTilingFeatures: TVkFormatFeatureFlags;
    optimalTilingFeatures: TVkFormatFeatureFlags;
    bufferFeatures: TVkFormatFeatureFlags;
  end;
  PVkFormatProperties = ^TVkFormatProperties;

  TVkImageFormatProperties = record
    maxExtent: TVkExtent3D;
    maxMipLevels: uint32_t;
    maxArrayLayers: uint32_t;
    sampleCounts: TVkSampleCountFlags;
    maxResourceSize: TVkDeviceSize;
  end;
  PVkImageFormatProperties = ^TVkImageFormatProperties;

  TVkDescriptorBufferInfo = record
    buffer: TVkBuffer;
    offset: TVkDeviceSize;
    range: TVkDeviceSize;
  end;
  PVkDescriptorBufferInfo = ^TVkDescriptorBufferInfo;

  TVkDescriptorImageInfo = record
    sampler: TVkSampler;
    imageView: TVkImageView;
    imageLayout: TVkImageLayout;
  end;
  PVkDescriptorImageInfo = ^TVkDescriptorImageInfo;

  TVkWriteDescriptorSet = record
    sType: TVkStructureType;
    pNext: Pointer;
    dstSet: TVkDescriptorSet;
    dstBinding: uint32_t;
    dstArrayElement: uint32_t;
    descriptorCount: uint32_t;
    descriptorType: TVkDescriptorType;
    pImageInfo: PVkDescriptorImageInfo;
    pBufferInfo: PVkDescriptorBufferInfo;
    pTexelBufferView: PVkBufferView;
  end;
  PVkWriteDescriptorSet = ^TVkWriteDescriptorSet;

  TVkCopyDescriptorSet = record
    sType: TVkStructureType;
    pNext: Pointer;
    srcSet: TVkDescriptorSet;
    srcBinding: uint32_t;
    srcArrayElement: uint32_t;
    dstSet: TVkDescriptorSet;
    dstBinding: uint32_t;
    dstArrayElement: uint32_t;
    descriptorCount: uint32_t;
  end;
  PVkCopyDescriptorSet = ^TVkCopyDescriptorSet;

  TVkBufferCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkBufferCreateFlags;
    size: TVkDeviceSize;
    usage: TVkBufferUsageFlags;
    sharingMode: TVkSharingMode;
    queueFamilyIndexCount: uint32_t;
    pQueueFamilyIndices: Puint32_t;
  end;
  PVkBufferCreateInfo = ^TVkBufferCreateInfo;

  TVkBufferViewCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkBufferViewCreateFlags;
    buffer: TVkBuffer;
    format: TVkFormat;
    offset: TVkDeviceSize;
    range: TVkDeviceSize;
  end;
  PVkBufferViewCreateInfo = ^TVkBufferViewCreateInfo;

  TVkImageSubresource = record
    aspectMask: TVkImageAspectFlags;
    mipLevel: uint32_t;
    arrayLayer: uint32_t;
  end;
  PVkImageSubresource = ^TVkImageSubresource;

  TVkImageSubresourceLayers = record
    aspectMask: TVkImageAspectFlags;
    mipLevel: uint32_t;
    baseArrayLayer: uint32_t;
    layerCount: uint32_t;
  end;

  TVkImageSubresourceRange = record
    aspectMask: TVkImageAspectFlags;
    baseMipLevel: uint32_t;
    levelCount: uint32_t;
    baseArrayLayer: uint32_t;
    layerCount: uint32_t;
  end;
  PVkImageSubresourceRange = ^TVkImageSubresourceRange;

  TVkMemoryBarrier = record
    sType: TVkStructureType;
    pNext: Pointer;
    srcAccessMask: TVkAccessFlags;
    dstAccessMask: TVkAccessFlags;
  end;
  PVkMemoryBarrier = ^TVkMemoryBarrier;

  TVkBufferMemoryBarrier = record
    sType: TVkStructureType;
    pNext: Pointer;
    srcAccessMask: TVkAccessFlags;
    dstAccessMask: TVkAccessFlags;
    srcQueueFamilyIndex: uint32_t;
    dstQueueFamilyIndex: uint32_t;
    buffer: TVkBuffer;
    offset: TVkDeviceSize;
    size: TVkDeviceSize;
  end;
  PVkBufferMemoryBarrier = ^TVkBufferMemoryBarrier;

  TVkImageMemoryBarrier = record
    sType: TVkStructureType;
    pNext: Pointer;
    srcAccessMask: TVkAccessFlags;
    dstAccessMask: TVkAccessFlags;
    oldLayout: TVkImageLayout;
    newLayout: TVkImageLayout;
    srcQueueFamilyIndex: uint32_t;
    dstQueueFamilyIndex: uint32_t;
    image: TVkImage;
    subresourceRange: TVkImageSubresourceRange;
  end;
  PVkImageMemoryBarrier = ^TVkImageMemoryBarrier;

  TVkImageCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkImageCreateFlags;
    imageType: TVkImageType;
    format: TVkFormat;
    extent: TVkExtent3D;
    mipLevels: uint32_t;
    arrayLayers: uint32_t;
    samples: TVkSampleCountFlagBits;
    tiling: TVkImageTiling;
    usage: TVkImageUsageFlags;
    sharingMode: TVkSharingMode;
    queueFamilyIndexCount: uint32_t;
    pQueueFamilyIndices: Puint32_t;
    initialLayout: TVkImageLayout;
  end;
  PVkImageCreateInfo = ^TVkImageCreateInfo;

  TVkSubresourceLayout = record
    offset: TVkDeviceSize;
    size: TVkDeviceSize;
    rowPitch: TVkDeviceSize;
    arrayPitch: TVkDeviceSize;
    depthPitch: TVkDeviceSize;
  end;
  PVkSubresourceLayout = ^TVkSubresourceLayout;

  TVkImageViewCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkImageViewCreateFlags;
    image: TVkImage;
    viewType: TVkImageViewType;
    format: TVkFormat;
    components: TVkComponentMapping;
    subresourceRange: TVkImageSubresourceRange;
  end;
  PVkImageViewCreateInfo = ^TVkImageViewCreateInfo;

  TVkBufferCopy = record
    srcOffset: TVkDeviceSize;
    dstOffset: TVkDeviceSize;
    size: TVkDeviceSize;
  end;
  PVkBufferCopy = ^TVkBufferCopy;

  TVkSparseMemoryBind = record
    resourceOffset: TVkDeviceSize;
    size: TVkDeviceSize;
    memory: TVkDeviceMemory;
    memoryOffset: TVkDeviceSize;
    flags: TVkSparseMemoryBindFlags;
  end;
  PVkSparseMemoryBind = ^TVkSparseMemoryBind;

  TVkSparseImageMemoryBind = record
    subresource: TVkImageSubresource;
    offset: TVkOffset3D;
    extent: TVkExtent3D;
    memory: TVkDeviceMemory;
    memoryOffset: TVkDeviceSize;
    flags: TVkSparseMemoryBindFlags;
  end;
  PVkSparseImageMemoryBind = ^TVkSparseImageMemoryBind;

  TVkSparseBufferMemoryBindInfo = record
    buffer: TVkBuffer;
    bindCount: uint32_t;
    pBinds: PVkSparseMemoryBind;
  end;
  PVkSparseBufferMemoryBindInfo = ^TVkSparseBufferMemoryBindInfo;

  TVkSparseImageOpaqueMemoryBindInfo = record
    image: TVkImage;
    bindCount: uint32_t;
    pBinds: PVkSparseMemoryBind;
  end;
  PVkSparseImageOpaqueMemoryBindInfo = ^TVkSparseImageOpaqueMemoryBindInfo;

  TVkSparseImageMemoryBindInfo = record
    image: TVkImage;
    bindCount: uint32_t;
    pBinds: PVkSparseImageMemoryBind;
  end;
  PVkSparseImageMemoryBindInfo = ^TVkSparseImageMemoryBindInfo;

  TVkBindSparseInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    waitSemaphoreCount: uint32_t;
    pWaitSemaphores: PVkSemaphore;
    bufferBindCount: uint32_t;
    pBufferBinds: PVkSparseBufferMemoryBindInfo;
    imageOpaqueBindCount: uint32_t;
    pImageOpaqueBinds: PVkSparseImageOpaqueMemoryBindInfo;
    imageBindCount: uint32_t;
    pImageBinds: PVkSparseImageMemoryBindInfo;
    signalSemaphoreCount: uint32_t;
    pSignalSemaphores: PVkSemaphore;
  end;
  PVkBindSparseInfo = ^TVkBindSparseInfo;

  TVkImageCopy = record
    srcSubresource: TVkImageSubresourceLayers;
    srcOffset: TVkOffset3D;
    dstSubresource: TVkImageSubresourceLayers;
    dstOffset: TVkOffset3D;
    extent: TVkExtent3D;
  end;
  PVkImageCopy = ^TVkImageCopy;

  TVkImageBlit = record
    srcSubresource: TVkImageSubresourceLayers;
    srcOffsets: array[0..1] of TVkOffset3D;
    dstSubresource: TVkImageSubresourceLayers;
    dstOffsets: array[0..1] of TVkOffset3D;
  end;
  PVkImageBlit = ^TVkImageBlit;

  TVkBufferImageCopy = record
    bufferOffset: TVkDeviceSize;
    bufferRowLength: uint32_t;
    bufferImageHeight: uint32_t;
    imageSubresource: TVkImageSubresourceLayers;
    imageOffset: TVkOffset3D;
    imageExtent: TVkExtent3D;
  end;
  PVkBufferImageCopy = ^TVkBufferImageCopy;

  TVkImageResolve = record
    srcSubresource: TVkImageSubresourceLayers;
    srcOffset: TVkOffset3D;
    dstSubresource: TVkImageSubresourceLayers;
    dstOffset: TVkOffset3D;
    extent: TVkExtent3D;
  end;
  PVkImageResolve = ^TVkImageResolve;

  TVkShaderModuleCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkShaderModuleCreateFlags;
    codeSize: size_t;
    pCode: Puint32_t;
  end;
  PVkShaderModuleCreateInfo = ^TVkShaderModuleCreateInfo;

  TVkDescriptorSetLayoutBinding = record
    binding: uint32_t;
    descriptorType: TVkDescriptorType;
    descriptorCount: uint32_t;
    stageFlags: TVkShaderStageFlags;
    pImmutableSamplers: PVkSampler;
  end;
  PVkDescriptorSetLayoutBinding = ^TVkDescriptorSetLayoutBinding;

  TVkDescriptorSetLayoutCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkDescriptorSetLayoutCreateFlags;
    bindingCount: uint32_t;
    pBindings: PVkDescriptorSetLayoutBinding;
  end;
  PVkDescriptorSetLayoutCreateInfo = ^TVkDescriptorSetLayoutCreateInfo;

  TVkDescriptorPoolSize = record
    type_: TVkDescriptorType;
    descriptorCount: uint32_t;
  end;
  PVkDescriptorPoolSize = ^TVkDescriptorPoolSize;

  TVkDescriptorPoolCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkDescriptorPoolCreateFlags;
    maxSets: uint32_t;
    poolSizeCount: uint32_t;
    pPoolSizes: PVkDescriptorPoolSize;
  end;
  PVkDescriptorPoolCreateInfo = ^TVkDescriptorPoolCreateInfo;

  TVkDescriptorSetAllocateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    descriptorPool: TVkDescriptorPool;
    descriptorSetCount: uint32_t;
    pSetLayouts: PVkDescriptorSetLayout;
  end;
  PVkDescriptorSetAllocateInfo = ^TVkDescriptorSetAllocateInfo;

  TVkSpecializationMapEntry = record
    constantID: uint32_t;
    offset: uint32_t;
    size: size_t;
  end;
  PVkSpecializationMapEntry = ^TVkSpecializationMapEntry;

  TVkSpecializationInfo = record
    mapEntryCount: uint32_t;
    pMapEntries: PVkSpecializationMapEntry;
    dataSize: size_t;
    pData: Pointer;
  end;
  PVkSpecializationInfo = ^TVkSpecializationInfo;

  TVkPipelineShaderStageCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineShaderStageCreateFlags;
    stage: TVkShaderStageFlagBits;
    module: TVkShaderModule;
    pName: Pchar;
    pSpecializationInfo: PVkSpecializationInfo;
  end;
  PVkPipelineShaderStageCreateInfo = ^TVkPipelineShaderStageCreateInfo;

  TVkComputePipelineCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineCreateFlags;
    stage: TVkPipelineShaderStageCreateInfo;
    layout: TVkPipelineLayout;
    basePipelineHandle: TVkPipeline;
    basePipelineIndex: int32_t;
  end;
  PVkComputePipelineCreateInfo = ^TVkComputePipelineCreateInfo;

  TVkVertexInputBindingDescription = record
    binding: uint32_t;
    stride: uint32_t;
    inputRate: TVkVertexInputRate;
  end;
  PVkVertexInputBindingDescription = ^TVkVertexInputBindingDescription;

  TVkVertexInputAttributeDescription = record
    location: uint32_t;
    binding: uint32_t;
    format: TVkFormat;
    offset: uint32_t;
  end;
  PVkVertexInputAttributeDescription = ^TVkVertexInputAttributeDescription;

  TVkPipelineVertexInputStateCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineVertexInputStateCreateFlags;
    vertexBindingDescriptionCount: uint32_t;
    pVertexBindingDescriptions: PVkVertexInputBindingDescription;
    vertexAttributeDescriptionCount: uint32_t;
    pVertexAttributeDescriptions: PVkVertexInputAttributeDescription;
  end;
  PVkPipelineVertexInputStateCreateInfo = ^TVkPipelineVertexInputStateCreateInfo;

  TVkPipelineInputAssemblyStateCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineInputAssemblyStateCreateFlags;
    topology: TVkPrimitiveTopology;
    primitiveRestartEnable: TVkBool32;
  end;
  PVkPipelineInputAssemblyStateCreateInfo = ^TVkPipelineInputAssemblyStateCreateInfo;

  TVkPipelineTessellationStateCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineTessellationStateCreateFlags;
    patchControlPoints: uint32_t;
  end;
  PVkPipelineTessellationStateCreateInfo = ^TVkPipelineTessellationStateCreateInfo;

  TVkPipelineViewportStateCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineViewportStateCreateFlags;
    viewportCount: uint32_t;
    pViewports: PVkViewport;
    scissorCount: uint32_t;
    pScissors: PVkRect2D;
  end;
  PVkPipelineViewportStateCreateInfo = ^TVkPipelineViewportStateCreateInfo;

  TVkPipelineRasterizationStateCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineRasterizationStateCreateFlags;
    depthClampEnable: TVkBool32;
    rasterizerDiscardEnable: TVkBool32;
    polygonMode: TVkPolygonMode;
    cullMode: TVkCullModeFlags;
    frontFace: TVkFrontFace;
    depthBiasEnable: TVkBool32;
    depthBiasConstantFactor: float;
    depthBiasClamp: float;
    depthBiasSlopeFactor: float;
    lineWidth: float;
  end;
  PVkPipelineRasterizationStateCreateInfo = ^TVkPipelineRasterizationStateCreateInfo;

  TVkPipelineMultisampleStateCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineMultisampleStateCreateFlags;
    rasterizationSamples: TVkSampleCountFlagBits;
    sampleShadingEnable: TVkBool32;
    minSampleShading: float;
    pSampleMask: PVkSampleMask;
    alphaToCoverageEnable: TVkBool32;
    alphaToOneEnable: TVkBool32;
  end;
  PVkPipelineMultisampleStateCreateInfo = ^TVkPipelineMultisampleStateCreateInfo;

  TVkPipelineColorBlendAttachmentState = record
    blendEnable: TVkBool32;
    srcColorBlendFactor: TVkBlendFactor;
    dstColorBlendFactor: TVkBlendFactor;
    colorBlendOp: TVkBlendOp;
    srcAlphaBlendFactor: TVkBlendFactor;
    dstAlphaBlendFactor: TVkBlendFactor;
    alphaBlendOp: TVkBlendOp;
    colorWriteMask: TVkColorComponentFlags;
  end;
  PVkPipelineColorBlendAttachmentState = ^TVkPipelineColorBlendAttachmentState;

  TVkPipelineColorBlendStateCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineColorBlendStateCreateFlags;
    logicOpEnable: TVkBool32;
    logicOp: TVkLogicOp;
    attachmentCount: uint32_t;
    pAttachments: PVkPipelineColorBlendAttachmentState;
    blendConstants: array[0..3] of float;
  end;
  PVkPipelineColorBlendStateCreateInfo = ^TVkPipelineColorBlendStateCreateInfo;

  TVkPipelineDynamicStateCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineDynamicStateCreateFlags;
    dynamicStateCount: uint32_t;
    pDynamicStates: PVkDynamicState;
  end;
  PVkPipelineDynamicStateCreateInfo = ^TVkPipelineDynamicStateCreateInfo;

  TVkStencilOpState = record
    failOp: TVkStencilOp;
    passOp: TVkStencilOp;
    depthFailOp: TVkStencilOp;
    compareOp: TVkCompareOp;
    compareMask: uint32_t;
    writeMask: uint32_t;
    reference: uint32_t;
  end;

  TVkPipelineDepthStencilStateCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineDepthStencilStateCreateFlags;
    depthTestEnable: TVkBool32;
    depthWriteEnable: TVkBool32;
    depthCompareOp: TVkCompareOp;
    depthBoundsTestEnable: TVkBool32;
    stencilTestEnable: TVkBool32;
    front: TVkStencilOpState;
    back: TVkStencilOpState;
    minDepthBounds: float;
    maxDepthBounds: float;
  end;
  PVkPipelineDepthStencilStateCreateInfo = ^TVkPipelineDepthStencilStateCreateInfo;

  TVkGraphicsPipelineCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineCreateFlags;
    stageCount: uint32_t;
    pStages: PVkPipelineShaderStageCreateInfo;
    pVertexInputState: PVkPipelineVertexInputStateCreateInfo;
    pInputAssemblyState: PVkPipelineInputAssemblyStateCreateInfo;
    pTessellationState: PVkPipelineTessellationStateCreateInfo;
    pViewportState: PVkPipelineViewportStateCreateInfo;
    pRasterizationState: PVkPipelineRasterizationStateCreateInfo;
    pMultisampleState: PVkPipelineMultisampleStateCreateInfo;
    pDepthStencilState: PVkPipelineDepthStencilStateCreateInfo;
    pColorBlendState: PVkPipelineColorBlendStateCreateInfo;
    pDynamicState: PVkPipelineDynamicStateCreateInfo;
    layout: TVkPipelineLayout;
    renderPass: TVkRenderPass;
    subpass: uint32_t;
    basePipelineHandle: TVkPipeline;
    basePipelineIndex: int32_t;
  end;
  PVkGraphicsPipelineCreateInfo = ^TVkGraphicsPipelineCreateInfo;

  TVkPipelineCacheCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineCacheCreateFlags;
    initialDataSize: size_t;
    pInitialData: Pointer;
  end;
  PVkPipelineCacheCreateInfo = ^TVkPipelineCacheCreateInfo;

  TVkPushConstantRange = record
    stageFlags: TVkShaderStageFlags;
    offset: uint32_t;
    size: uint32_t;
  end;
  PVkPushConstantRange = ^TVkPushConstantRange;

  TVkPipelineLayoutCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineLayoutCreateFlags;
    setLayoutCount: uint32_t;
    pSetLayouts: PVkDescriptorSetLayout;
    pushConstantRangeCount: uint32_t;
    pPushConstantRanges: PVkPushConstantRange;
  end;
  PVkPipelineLayoutCreateInfo = ^TVkPipelineLayoutCreateInfo;

  TVkSamplerCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkSamplerCreateFlags;
    magFilter: TVkFilter;
    minFilter: TVkFilter;
    mipmapMode: TVkSamplerMipmapMode;
    addressModeU: TVkSamplerAddressMode;
    addressModeV: TVkSamplerAddressMode;
    addressModeW: TVkSamplerAddressMode;
    mipLodBias: float;
    anisotropyEnable: TVkBool32;
    maxAnisotropy: float;
    compareEnable: TVkBool32;
    compareOp: TVkCompareOp;
    minLod: float;
    maxLod: float;
    borderColor: TVkBorderColor;
    unnormalizedCoordinates: TVkBool32;
  end;
  PVkSamplerCreateInfo = ^TVkSamplerCreateInfo;

  TVkCommandPoolCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkCommandPoolCreateFlags;
    queueFamilyIndex: uint32_t;
  end;
  PVkCommandPoolCreateInfo = ^TVkCommandPoolCreateInfo;

  TVkCommandBufferAllocateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    commandPool: TVkCommandPool;
    level: TVkCommandBufferLevel;
    commandBufferCount: uint32_t;
  end;
  PVkCommandBufferAllocateInfo = ^TVkCommandBufferAllocateInfo;

  TVkCommandBufferInheritanceInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    renderPass: TVkRenderPass;
    subpass: uint32_t;
    framebuffer: TVkFramebuffer;
    occlusionQueryEnable: TVkBool32;
    queryFlags: TVkQueryControlFlags;
    pipelineStatistics: TVkQueryPipelineStatisticFlags;
  end;
  PVkCommandBufferInheritanceInfo = ^TVkCommandBufferInheritanceInfo;

  TVkCommandBufferBeginInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkCommandBufferUsageFlags;
    pInheritanceInfo: PVkCommandBufferInheritanceInfo;
  end;
  PVkCommandBufferBeginInfo = ^TVkCommandBufferBeginInfo;

  TVkClearColorValue = record
    case Integer of
      0: (      float32: array[0..3] of float;
);
      1: (      int32: array[0..3] of int32_t;
);
      2: (      uint32: array[0..3] of uint32_t;
);
  end;
  PVkClearColorValue = ^TVkClearColorValue;

  TVkClearDepthStencilValue = record
    depth: float;
    stencil: uint32_t;
  end;
  PVkClearDepthStencilValue = ^TVkClearDepthStencilValue;

  TVkClearValue = record
    case Integer of
      0: (      color: TVkClearColorValue;
);
      1: (      depthStencil: TVkClearDepthStencilValue;
);
  end;
  PVkClearValue = ^TVkClearValue;

  TVkRenderPassBeginInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    renderPass: TVkRenderPass;
    framebuffer: TVkFramebuffer;
    renderArea: TVkRect2D;
    clearValueCount: uint32_t;
    pClearValues: PVkClearValue;
  end;
  PVkRenderPassBeginInfo = ^TVkRenderPassBeginInfo;

  TVkClearAttachment = record
    aspectMask: TVkImageAspectFlags;
    colorAttachment: uint32_t;
    clearValue: TVkClearValue;
  end;
  PVkClearAttachment = ^TVkClearAttachment;

  TVkAttachmentDescription = record
    flags: TVkAttachmentDescriptionFlags;
    format: TVkFormat;
    samples: TVkSampleCountFlagBits;
    loadOp: TVkAttachmentLoadOp;
    storeOp: TVkAttachmentStoreOp;
    stencilLoadOp: TVkAttachmentLoadOp;
    stencilStoreOp: TVkAttachmentStoreOp;
    initialLayout: TVkImageLayout;
    finalLayout: TVkImageLayout;
  end;
  PVkAttachmentDescription = ^TVkAttachmentDescription;

  TVkAttachmentReference = record
    attachment: uint32_t;
    layout: TVkImageLayout;
  end;
  PVkAttachmentReference = ^TVkAttachmentReference;

  TVkSubpassDescription = record
    flags: TVkSubpassDescriptionFlags;
    pipelineBindPoint: TVkPipelineBindPoint;
    inputAttachmentCount: uint32_t;
    pInputAttachments: PVkAttachmentReference;
    colorAttachmentCount: uint32_t;
    pColorAttachments: PVkAttachmentReference;
    pResolveAttachments: PVkAttachmentReference;
    pDepthStencilAttachment: PVkAttachmentReference;
    preserveAttachmentCount: uint32_t;
    pPreserveAttachments: Puint32_t;
  end;
  PVkSubpassDescription = ^TVkSubpassDescription;

  TVkSubpassDependency = record
    srcSubpass: uint32_t;
    dstSubpass: uint32_t;
    srcStageMask: TVkPipelineStageFlags;
    dstStageMask: TVkPipelineStageFlags;
    srcAccessMask: TVkAccessFlags;
    dstAccessMask: TVkAccessFlags;
    dependencyFlags: TVkDependencyFlags;
  end;
  PVkSubpassDependency = ^TVkSubpassDependency;

  TVkRenderPassCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkRenderPassCreateFlags;
    attachmentCount: uint32_t;
    pAttachments: PVkAttachmentDescription;
    subpassCount: uint32_t;
    pSubpasses: PVkSubpassDescription;
    dependencyCount: uint32_t;
    pDependencies: PVkSubpassDependency;
  end;
  PVkRenderPassCreateInfo = ^TVkRenderPassCreateInfo;

  TVkEventCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkEventCreateFlags;
  end;
  PVkEventCreateInfo = ^TVkEventCreateInfo;

  TVkFenceCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkFenceCreateFlags;
  end;
  PVkFenceCreateInfo = ^TVkFenceCreateInfo;

  TVkSemaphoreCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkSemaphoreCreateFlags;
  end;
  PVkSemaphoreCreateInfo = ^TVkSemaphoreCreateInfo;

  TVkQueryPoolCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkQueryPoolCreateFlags;
    queryType: TVkQueryType;
    queryCount: uint32_t;
    pipelineStatistics: TVkQueryPipelineStatisticFlags;
  end;
  PVkQueryPoolCreateInfo = ^TVkQueryPoolCreateInfo;

  TVkFramebufferCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkFramebufferCreateFlags;
    renderPass: TVkRenderPass;
    attachmentCount: uint32_t;
    pAttachments: PVkImageView;
    width: uint32_t;
    height: uint32_t;
    layers: uint32_t;
  end;
  PVkFramebufferCreateInfo = ^TVkFramebufferCreateInfo;

  TVkDrawIndirectCommand = record
    vertexCount: uint32_t;
    instanceCount: uint32_t;
    firstVertex: uint32_t;
    firstInstance: uint32_t;
  end;

  TVkDrawIndexedIndirectCommand = record
    indexCount: uint32_t;
    instanceCount: uint32_t;
    firstIndex: uint32_t;
    vertexOffset: int32_t;
    firstInstance: uint32_t;
  end;

  TVkDispatchIndirectCommand = record
    x: uint32_t;
    y: uint32_t;
    z: uint32_t;
  end;

  TVkSubmitInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    waitSemaphoreCount: uint32_t;
    pWaitSemaphores: PVkSemaphore;
    pWaitDstStageMask: PVkPipelineStageFlags;
    commandBufferCount: uint32_t;
    pCommandBuffers: PVkCommandBuffer;
    signalSemaphoreCount: uint32_t;
    pSignalSemaphores: PVkSemaphore;
  end;
  PVkSubmitInfo = ^TVkSubmitInfo;

  { WSI extensions }


  TVkDisplayPropertiesKHR = record
    display: TVkDisplayKHR;
    displayName: Pchar;
    physicalDimensions: TVkExtent2D;
    physicalResolution: TVkExtent2D;
    supportedTransforms: TVkSurfaceTransformFlagsKHR;
    planeReorderPossible: TVkBool32;
    persistentContent: TVkBool32;
  end;
  PVkDisplayPropertiesKHR = ^TVkDisplayPropertiesKHR;

  TVkDisplayPlanePropertiesKHR = record
    currentDisplay: TVkDisplayKHR;
    currentStackIndex: uint32_t;
  end;
  PVkDisplayPlanePropertiesKHR = ^TVkDisplayPlanePropertiesKHR;

  TVkDisplayModeParametersKHR = record
    visibleRegion: TVkExtent2D;
    refreshRate: uint32_t;
  end;

  TVkDisplayModePropertiesKHR = record
    displayMode: TVkDisplayModeKHR;
    parameters: TVkDisplayModeParametersKHR;
  end;
  PVkDisplayModePropertiesKHR = ^TVkDisplayModePropertiesKHR;

  TVkDisplayModeCreateInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkDisplayModeCreateFlagsKHR;
    parameters: TVkDisplayModeParametersKHR;
  end;
  PVkDisplayModeCreateInfoKHR = ^TVkDisplayModeCreateInfoKHR;

  TVkDisplayPlaneCapabilitiesKHR = record
    supportedAlpha: TVkDisplayPlaneAlphaFlagsKHR;
    minSrcPosition: TVkOffset2D;
    maxSrcPosition: TVkOffset2D;
    minSrcExtent: TVkExtent2D;
    maxSrcExtent: TVkExtent2D;
    minDstPosition: TVkOffset2D;
    maxDstPosition: TVkOffset2D;
    minDstExtent: TVkExtent2D;
    maxDstExtent: TVkExtent2D;
  end;
  PVkDisplayPlaneCapabilitiesKHR = ^TVkDisplayPlaneCapabilitiesKHR;

  TVkDisplaySurfaceCreateInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkDisplaySurfaceCreateFlagsKHR;
    displayMode: TVkDisplayModeKHR;
    planeIndex: uint32_t;
    planeStackIndex: uint32_t;
    transform: TVkSurfaceTransformFlagBitsKHR;
    globalAlpha: float;
    alphaMode: TVkDisplayPlaneAlphaFlagBitsKHR;
    imageExtent: TVkExtent2D;
  end;
  PVkDisplaySurfaceCreateInfoKHR = ^TVkDisplaySurfaceCreateInfoKHR;

  TVkDisplayPresentInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    srcRect: TVkRect2D;
    dstRect: TVkRect2D;
    persistent: TVkBool32;
  end;

  TVkSurfaceCapabilitiesKHR = record
    minImageCount: uint32_t;
    maxImageCount: uint32_t;
    currentExtent: TVkExtent2D;
    minImageExtent: TVkExtent2D;
    maxImageExtent: TVkExtent2D;
    maxImageArrayLayers: uint32_t;
    supportedTransforms: TVkSurfaceTransformFlagsKHR;
    currentTransform: TVkSurfaceTransformFlagBitsKHR;
    supportedCompositeAlpha: TVkCompositeAlphaFlagsKHR;
    supportedUsageFlags: TVkImageUsageFlags;
  end;
  PVkSurfaceCapabilitiesKHR = ^TVkSurfaceCapabilitiesKHR;

{$IFDEF VK_USE_PLATFORM_ANDROID_KHR}
  TVkAndroidSurfaceCreateInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkAndroidSurfaceCreateFlagsKHR;
    window: PANativeWindow;
  end;
  PVkAndroidSurfaceCreateInfoKHR = ^TVkAndroidSurfaceCreateInfoKHR;
{$ENDIF VK_USE_PLATFORM_ANDROID_KHR}

{$IFDEF VK_USE_PLATFORM_MIR_KHR}
  TVkMirSurfaceCreateInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkMirSurfaceCreateFlagsKHR;
    connection: PMirConnection;
    mirSurface: PMirSurface;
  end;
  PVkMirSurfaceCreateInfoKHR = ^TVkMirSurfaceCreateInfoKHR;
{$ENDIF VK_USE_PLATFORM_MIR_KHR}

{$IFDEF VK_USE_PLATFORM_VI_NN}
  TVkViSurfaceCreateInfoNN = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkViSurfaceCreateFlagsNN;
    window: Pointer;
  end;
  PVkViSurfaceCreateInfoNN = ^TVkViSurfaceCreateInfoNN;
{$ENDIF VK_USE_PLATFORM_VI_NN}

{$IFDEF VK_USE_PLATFORM_WAYLAND_KHR}
  TVkWaylandSurfaceCreateInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkWaylandSurfaceCreateFlagsKHR;
    display: Pwl_display;
    surface: Pwl_surface;
  end;
  PVkWaylandSurfaceCreateInfoKHR = ^TVkWaylandSurfaceCreateInfoKHR;
{$ENDIF VK_USE_PLATFORM_WAYLAND_KHR}

{$IFDEF VK_USE_PLATFORM_WIN32_KHR}
  TVkWin32SurfaceCreateInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkWin32SurfaceCreateFlagsKHR;
    hinstance: HINST;
    hwnd: HWND;
  end;
  PVkWin32SurfaceCreateInfoKHR = ^TVkWin32SurfaceCreateInfoKHR;
{$ENDIF VK_USE_PLATFORM_WIN32_KHR}

{$IFDEF VK_USE_PLATFORM_XLIB_KHR}
  TVkXlibSurfaceCreateInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkXlibSurfaceCreateFlagsKHR;
    dpy: PDisplay;
    window: TWindow;
  end;
  PVkXlibSurfaceCreateInfoKHR = ^TVkXlibSurfaceCreateInfoKHR;
{$ENDIF VK_USE_PLATFORM_XLIB_KHR}

{$IFDEF VK_USE_PLATFORM_XCB_KHR}
  TVkXcbSurfaceCreateInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkXcbSurfaceCreateFlagsKHR;
    connection: Pxcb_connection_t;
    window: Txcb_window_t;
  end;
  PVkXcbSurfaceCreateInfoKHR = ^TVkXcbSurfaceCreateInfoKHR;
{$ENDIF VK_USE_PLATFORM_XCB_KHR}

  TVkSurfaceFormatKHR = record
    format: TVkFormat;
    colorSpace: TVkColorSpaceKHR;
  end;
  PVkSurfaceFormatKHR = ^TVkSurfaceFormatKHR;

  TVkSwapchainCreateInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkSwapchainCreateFlagsKHR;
    surface: TVkSurfaceKHR;
    minImageCount: uint32_t;
    imageFormat: TVkFormat;
    imageColorSpace: TVkColorSpaceKHR;
    imageExtent: TVkExtent2D;
    imageArrayLayers: uint32_t;
    imageUsage: TVkImageUsageFlags;
    imageSharingMode: TVkSharingMode;
    queueFamilyIndexCount: uint32_t;
    pQueueFamilyIndices: Puint32_t;
    preTransform: TVkSurfaceTransformFlagBitsKHR;
    compositeAlpha: TVkCompositeAlphaFlagBitsKHR;
    presentMode: TVkPresentModeKHR;
    clipped: TVkBool32;
    oldSwapchain: TVkSwapchainKHR;
  end;
  PVkSwapchainCreateInfoKHR = ^TVkSwapchainCreateInfoKHR;

  TVkPresentInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    waitSemaphoreCount: uint32_t;
    pWaitSemaphores: PVkSemaphore;
    swapchainCount: uint32_t;
    pSwapchains: PVkSwapchainKHR;
    pImageIndices: Puint32_t;
    pResults: PVkResult;
  end;
  PVkPresentInfoKHR = ^TVkPresentInfoKHR;

  TVkDebugReportCallbackCreateInfoEXT = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkDebugReportFlagsEXT;
    pfnCallback: TPFN_vkDebugReportCallbackEXT;
    pUserData: Pointer;
  end;
  PVkDebugReportCallbackCreateInfoEXT = ^TVkDebugReportCallbackCreateInfoEXT;

  TVkValidationFlagsEXT = record
    sType: TVkStructureType;
    pNext: Pointer;
    disabledValidationCheckCount: uint32_t;
    pDisabledValidationChecks: PVkValidationCheckEXT;
  end;

  TVkPipelineRasterizationStateRasterizationOrderAMD = record
    sType: TVkStructureType;
    pNext: Pointer;
    rasterizationOrder: TVkRasterizationOrderAMD;
  end;

  TVkDebugMarkerObjectNameInfoEXT = record
    sType: TVkStructureType;
    pNext: Pointer;
    objectType: TVkDebugReportObjectTypeEXT;
    object_: uint64_t;
    pObjectName: Pchar;
  end;
  PVkDebugMarkerObjectNameInfoEXT = ^TVkDebugMarkerObjectNameInfoEXT;

  TVkDebugMarkerObjectTagInfoEXT = record
    sType: TVkStructureType;
    pNext: Pointer;
    objectType: TVkDebugReportObjectTypeEXT;
    object_: uint64_t;
    tagName: uint64_t;
    tagSize: size_t;
    pTag: Pointer;
  end;
  PVkDebugMarkerObjectTagInfoEXT = ^TVkDebugMarkerObjectTagInfoEXT;

  TVkDebugMarkerMarkerInfoEXT = record
    sType: TVkStructureType;
    pNext: Pointer;
    pMarkerName: Pchar;
    color: array[0..3] of float;
  end;
  PVkDebugMarkerMarkerInfoEXT = ^TVkDebugMarkerMarkerInfoEXT;

  TVkDedicatedAllocationImageCreateInfoNV = record
    sType: TVkStructureType;
    pNext: Pointer;
    dedicatedAllocation: TVkBool32;
  end;

  TVkDedicatedAllocationBufferCreateInfoNV = record
    sType: TVkStructureType;
    pNext: Pointer;
    dedicatedAllocation: TVkBool32;
  end;

  TVkDedicatedAllocationMemoryAllocateInfoNV = record
    sType: TVkStructureType;
    pNext: Pointer;
    image: TVkImage;
    buffer: TVkBuffer;
  end;

  TVkExternalImageFormatPropertiesNV = record
    imageFormatProperties: TVkImageFormatProperties;
    externalMemoryFeatures: TVkExternalMemoryFeatureFlagsNV;
    exportFromImportedHandleTypes: TVkExternalMemoryHandleTypeFlagsNV;
    compatibleHandleTypes: TVkExternalMemoryHandleTypeFlagsNV;
  end;
  PVkExternalImageFormatPropertiesNV = ^TVkExternalImageFormatPropertiesNV;

  TVkExternalMemoryImageCreateInfoNV = record
    sType: TVkStructureType;
    pNext: Pointer;
    handleTypes: TVkExternalMemoryHandleTypeFlagsNV;
  end;

  TVkExportMemoryAllocateInfoNV = record
    sType: TVkStructureType;
    pNext: Pointer;
    handleTypes: TVkExternalMemoryHandleTypeFlagsNV;
  end;

{$IFDEF VK_USE_PLATFORM_WIN32_KHR}
  TVkImportMemoryWin32HandleInfoNV = record
    sType: TVkStructureType;
    pNext: Pointer;
    handleType: TVkExternalMemoryHandleTypeFlagsNV;
    handle: THANDLE;
  end;
{$ENDIF VK_USE_PLATFORM_WIN32_KHR}

{$IFDEF VK_USE_PLATFORM_WIN32_KHR}
  TVkExportMemoryWin32HandleInfoNV = record
    sType: TVkStructureType;
    pNext: Pointer;
    pAttributes: PSECURITY_ATTRIBUTES;
    dwAccess: DWORD;
  end;
{$ENDIF VK_USE_PLATFORM_WIN32_KHR}

{$IFDEF VK_USE_PLATFORM_WIN32_KHR}
  TVkWin32KeyedMutexAcquireReleaseInfoNV = record
    sType: TVkStructureType;
    pNext: Pointer;
    acquireCount: uint32_t;
    pAcquireSyncs: PVkDeviceMemory;
    pAcquireKeys: Puint64_t;
    pAcquireTimeoutMilliseconds: Puint32_t;
    releaseCount: uint32_t;
    pReleaseSyncs: PVkDeviceMemory;
    pReleaseKeys: Puint64_t;
  end;
{$ENDIF VK_USE_PLATFORM_WIN32_KHR}

  TVkDeviceGeneratedCommandsFeaturesNVX = record
    sType: TVkStructureType;
    pNext: Pointer;
    computeBindingPointSupport: TVkBool32;
  end;
  PVkDeviceGeneratedCommandsFeaturesNVX = ^TVkDeviceGeneratedCommandsFeaturesNVX;

  TVkDeviceGeneratedCommandsLimitsNVX = record
    sType: TVkStructureType;
    pNext: Pointer;
    maxIndirectCommandsLayoutTokenCount: uint32_t;
    maxObjectEntryCounts: uint32_t;
    minSequenceCountBufferOffsetAlignment: uint32_t;
    minSequenceIndexBufferOffsetAlignment: uint32_t;
    minCommandsTokenBufferOffsetAlignment: uint32_t;
  end;
  PVkDeviceGeneratedCommandsLimitsNVX = ^TVkDeviceGeneratedCommandsLimitsNVX;

  TVkIndirectCommandsTokenNVX = record
    tokenType: TVkIndirectCommandsTokenTypeNVX;
    buffer: TVkBuffer;
    offset: TVkDeviceSize;
  end;
  PVkIndirectCommandsTokenNVX = ^TVkIndirectCommandsTokenNVX;

  TVkIndirectCommandsLayoutTokenNVX = record
    tokenType: TVkIndirectCommandsTokenTypeNVX;
    bindingUnit: uint32_t;
    dynamicCount: uint32_t;
    divisor: uint32_t;
  end;
  PVkIndirectCommandsLayoutTokenNVX = ^TVkIndirectCommandsLayoutTokenNVX;

  TVkIndirectCommandsLayoutCreateInfoNVX = record
    sType: TVkStructureType;
    pNext: Pointer;
    pipelineBindPoint: TVkPipelineBindPoint;
    flags: TVkIndirectCommandsLayoutUsageFlagsNVX;
    tokenCount: uint32_t;
    pTokens: PVkIndirectCommandsLayoutTokenNVX;
  end;
  PVkIndirectCommandsLayoutCreateInfoNVX = ^TVkIndirectCommandsLayoutCreateInfoNVX;

  TVkCmdProcessCommandsInfoNVX = record
    sType: TVkStructureType;
    pNext: Pointer;
    objectTable: TVkObjectTableNVX;
    indirectCommandsLayout: TVkIndirectCommandsLayoutNVX;
    indirectCommandsTokenCount: uint32_t;
    pIndirectCommandsTokens: PVkIndirectCommandsTokenNVX;
    maxSequencesCount: uint32_t;
    targetCommandBuffer: TVkCommandBuffer;
    sequencesCountBuffer: TVkBuffer;
    sequencesCountOffset: TVkDeviceSize;
    sequencesIndexBuffer: TVkBuffer;
    sequencesIndexOffset: TVkDeviceSize;
  end;
  PVkCmdProcessCommandsInfoNVX = ^TVkCmdProcessCommandsInfoNVX;

  TVkCmdReserveSpaceForCommandsInfoNVX = record
    sType: TVkStructureType;
    pNext: Pointer;
    objectTable: TVkObjectTableNVX;
    indirectCommandsLayout: TVkIndirectCommandsLayoutNVX;
    maxSequencesCount: uint32_t;
  end;
  PVkCmdReserveSpaceForCommandsInfoNVX = ^TVkCmdReserveSpaceForCommandsInfoNVX;

  TVkObjectTableCreateInfoNVX = record
    sType: TVkStructureType;
    pNext: Pointer;
    objectCount: uint32_t;
    pObjectEntryTypes: PVkObjectEntryTypeNVX;
    pObjectEntryCounts: Puint32_t;
    pObjectEntryUsageFlags: PVkObjectEntryUsageFlagsNVX;
    maxUniformBuffersPerDescriptor: uint32_t;
    maxStorageBuffersPerDescriptor: uint32_t;
    maxStorageImagesPerDescriptor: uint32_t;
    maxSampledImagesPerDescriptor: uint32_t;
    maxPipelineLayouts: uint32_t;
  end;
  PVkObjectTableCreateInfoNVX = ^TVkObjectTableCreateInfoNVX;

  TVkObjectTableEntryNVX = record
    type_: TVkObjectEntryTypeNVX;
    flags: TVkObjectEntryUsageFlagsNVX;
  end;
  PVkObjectTableEntryNVX = ^TVkObjectTableEntryNVX;
  PPVkObjectTableEntryNVX = ^PVkObjectTableEntryNVX;

  TVkObjectTablePipelineEntryNVX = record
    type_: TVkObjectEntryTypeNVX;
    flags: TVkObjectEntryUsageFlagsNVX;
    pipeline: TVkPipeline;
  end;

  TVkObjectTableDescriptorSetEntryNVX = record
    type_: TVkObjectEntryTypeNVX;
    flags: TVkObjectEntryUsageFlagsNVX;
    pipelineLayout: TVkPipelineLayout;
    descriptorSet: TVkDescriptorSet;
  end;

  TVkObjectTableVertexBufferEntryNVX = record
    type_: TVkObjectEntryTypeNVX;
    flags: TVkObjectEntryUsageFlagsNVX;
    buffer: TVkBuffer;
  end;

  TVkObjectTableIndexBufferEntryNVX = record
    type_: TVkObjectEntryTypeNVX;
    flags: TVkObjectEntryUsageFlagsNVX;
    buffer: TVkBuffer;
    indexType: TVkIndexType;
  end;

  TVkObjectTablePushConstantEntryNVX = record
    type_: TVkObjectEntryTypeNVX;
    flags: TVkObjectEntryUsageFlagsNVX;
    pipelineLayout: TVkPipelineLayout;
    stageFlags: TVkShaderStageFlags;
  end;

  TVkPhysicalDeviceFeatures2KHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    features: TVkPhysicalDeviceFeatures;
  end;
  PVkPhysicalDeviceFeatures2KHR = ^TVkPhysicalDeviceFeatures2KHR;

  TVkPhysicalDeviceProperties2KHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    properties: TVkPhysicalDeviceProperties;
  end;
  PVkPhysicalDeviceProperties2KHR = ^TVkPhysicalDeviceProperties2KHR;

  TVkFormatProperties2KHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    formatProperties: TVkFormatProperties;
  end;
  PVkFormatProperties2KHR = ^TVkFormatProperties2KHR;

  TVkImageFormatProperties2KHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    imageFormatProperties: TVkImageFormatProperties;
  end;
  PVkImageFormatProperties2KHR = ^TVkImageFormatProperties2KHR;

  TVkPhysicalDeviceImageFormatInfo2KHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    format: TVkFormat;
    type_: TVkImageType;
    tiling: TVkImageTiling;
    usage: TVkImageUsageFlags;
    flags: TVkImageCreateFlags;
  end;
  PVkPhysicalDeviceImageFormatInfo2KHR = ^TVkPhysicalDeviceImageFormatInfo2KHR;

  TVkQueueFamilyProperties2KHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    queueFamilyProperties: TVkQueueFamilyProperties;
  end;
  PVkQueueFamilyProperties2KHR = ^TVkQueueFamilyProperties2KHR;

  TVkPhysicalDeviceMemoryProperties2KHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    memoryProperties: TVkPhysicalDeviceMemoryProperties;
  end;
  PVkPhysicalDeviceMemoryProperties2KHR = ^TVkPhysicalDeviceMemoryProperties2KHR;

  TVkSparseImageFormatProperties2KHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    properties: TVkSparseImageFormatProperties;
  end;
  PVkSparseImageFormatProperties2KHR = ^TVkSparseImageFormatProperties2KHR;

  TVkPhysicalDeviceSparseImageFormatInfo2KHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    format: TVkFormat;
    type_: TVkImageType;
    samples: TVkSampleCountFlagBits;
    usage: TVkImageUsageFlags;
    tiling: TVkImageTiling;
  end;
  PVkPhysicalDeviceSparseImageFormatInfo2KHR = ^TVkPhysicalDeviceSparseImageFormatInfo2KHR;

  TVkPhysicalDevicePushDescriptorPropertiesKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    maxPushDescriptors: uint32_t;
  end;

  TVkRectLayerKHR = record
    offset: TVkOffset2D;
    extent: TVkExtent2D;
    layer: uint32_t;
  end;
  PVkRectLayerKHR = ^TVkRectLayerKHR;

  TVkPresentRegionKHR = record
    rectangleCount: uint32_t;
    pRectangles: PVkRectLayerKHR;
  end;
  PVkPresentRegionKHR = ^TVkPresentRegionKHR;

  TVkPresentRegionsKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    swapchainCount: uint32_t;
    pRegions: PVkPresentRegionKHR;
  end;

  TVkExternalMemoryPropertiesKHX = record
    externalMemoryFeatures: TVkExternalMemoryFeatureFlagsKHX;
    exportFromImportedHandleTypes: TVkExternalMemoryHandleTypeFlagsKHX;
    compatibleHandleTypes: TVkExternalMemoryHandleTypeFlagsKHX;
  end;

  TVkPhysicalDeviceExternalImageFormatInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    handleType: TVkExternalMemoryHandleTypeFlagBitsKHX;
  end;

  TVkExternalImageFormatPropertiesKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    externalMemoryProperties: TVkExternalMemoryPropertiesKHX;
  end;

  TVkPhysicalDeviceExternalBufferInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkBufferCreateFlags;
    usage: TVkBufferUsageFlags;
    handleType: TVkExternalMemoryHandleTypeFlagBitsKHX;
  end;
  PVkPhysicalDeviceExternalBufferInfoKHX = ^TVkPhysicalDeviceExternalBufferInfoKHX;

  TVkExternalBufferPropertiesKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    externalMemoryProperties: TVkExternalMemoryPropertiesKHX;
  end;
  PVkExternalBufferPropertiesKHX = ^TVkExternalBufferPropertiesKHX;

  TVkPhysicalDeviceIDPropertiesKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    deviceUUID: array[0..(VK_UUID_SIZE - 1)] of uint8_t;
    driverUUID: array[0..(VK_UUID_SIZE - 1)] of uint8_t;
    deviceLUID: array[0..(VK_LUID_SIZE_KHX - 1)] of uint8_t;
    deviceLUIDValid: TVkBool32;
  end;

  TVkExternalMemoryImageCreateInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    handleTypes: TVkExternalMemoryHandleTypeFlagsKHX;
  end;

  TVkExternalMemoryBufferCreateInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    handleTypes: TVkExternalMemoryHandleTypeFlagsKHX;
  end;

  TVkExportMemoryAllocateInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    handleTypes: TVkExternalMemoryHandleTypeFlagsKHX;
  end;

{$IFDEF VK_USE_PLATFORM_WIN32_KHX}
  TVkImportMemoryWin32HandleInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    handleType: TVkExternalMemoryHandleTypeFlagBitsKHX;
    handle: THANDLE;
  end;
{$ENDIF VK_USE_PLATFORM_WIN32_KHX}

{$IFDEF VK_USE_PLATFORM_WIN32_KHX}
  TVkExportMemoryWin32HandleInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    pAttributes: PSECURITY_ATTRIBUTES;
    dwAccess: DWORD;
    name_: LPCWSTR;
  end;
{$ENDIF VK_USE_PLATFORM_WIN32_KHX}

{$IFDEF VK_USE_PLATFORM_WIN32_KHX}
  TVkMemoryWin32HandlePropertiesKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    memoryTypeBits: uint32_t;
  end;
  PVkMemoryWin32HandlePropertiesKHX = ^TVkMemoryWin32HandlePropertiesKHX;
{$ENDIF VK_USE_PLATFORM_WIN32_KHX}

  TVkImportMemoryFdInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    handleType: TVkExternalMemoryHandleTypeFlagBitsKHX;
    fd: int;
  end;

  TVkMemoryFdPropertiesKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    memoryTypeBits: uint32_t;
  end;
  PVkMemoryFdPropertiesKHX = ^TVkMemoryFdPropertiesKHX;

{$IFDEF VK_USE_PLATFORM_WIN32_KHR}
  TVkWin32KeyedMutexAcquireReleaseInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    acquireCount: uint32_t;
    pAcquireSyncs: PVkDeviceMemory;
    pAcquireKeys: Puint64_t;
    pAcquireTimeouts: Puint32_t;
    releaseCount: uint32_t;
    pReleaseSyncs: PVkDeviceMemory;
    pReleaseKeys: Puint64_t;
  end;
{$ENDIF VK_USE_PLATFORM_WIN32_KHR}

  TVkPhysicalDeviceExternalSemaphoreInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    handleType: TVkExternalSemaphoreHandleTypeFlagBitsKHX;
  end;
  PVkPhysicalDeviceExternalSemaphoreInfoKHX = ^TVkPhysicalDeviceExternalSemaphoreInfoKHX;

  TVkExternalSemaphorePropertiesKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    exportFromImportedHandleTypes: TVkExternalSemaphoreHandleTypeFlagsKHX;
    compatibleHandleTypes: TVkExternalSemaphoreHandleTypeFlagsKHX;
    externalSemaphoreFeatures: TVkExternalSemaphoreFeatureFlagsKHX;
  end;
  PVkExternalSemaphorePropertiesKHX = ^TVkExternalSemaphorePropertiesKHX;

  TVkExportSemaphoreCreateInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    handleTypes: TVkExternalSemaphoreHandleTypeFlagsKHX;
  end;

{$IFDEF VK_USE_PLATFORM_WIN32_KHX}
  TVkImportSemaphoreWin32HandleInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    semaphore: TVkSemaphore;
    handleType: TVkExternalSemaphoreHandleTypeFlagsKHX;
    handle: THANDLE;
  end;
  PVkImportSemaphoreWin32HandleInfoKHX = ^TVkImportSemaphoreWin32HandleInfoKHX;
{$ENDIF VK_USE_PLATFORM_WIN32_KHX}

{$IFDEF VK_USE_PLATFORM_WIN32_KHX}
  TVkExportSemaphoreWin32HandleInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    pAttributes: PSECURITY_ATTRIBUTES;
    dwAccess: DWORD;
    name_: LPCWSTR;
  end;
{$ENDIF VK_USE_PLATFORM_WIN32_KHX}

{$IFDEF VK_USE_PLATFORM_WIN32_KHX}
  TVkD3D12FenceSubmitInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    waitSemaphoreValuesCount: uint32_t;
    pWaitSemaphoreValues: Puint64_t;
    signalSemaphoreValuesCount: uint32_t;
    pSignalSemaphoreValues: Puint64_t;
  end;
{$ENDIF VK_USE_PLATFORM_WIN32_KHX}

  TVkImportSemaphoreFdInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    semaphore: TVkSemaphore;
    handleType: TVkExternalSemaphoreHandleTypeFlagBitsKHX;
    fd: int;
  end;
  PVkImportSemaphoreFdInfoKHX = ^TVkImportSemaphoreFdInfoKHX;

  TVkPhysicalDeviceMultiviewFeaturesKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    multiview: TVkBool32;
    multiviewGeometryShader: TVkBool32;
    multiviewTessellationShader: TVkBool32;
  end;

  TVkPhysicalDeviceMultiviewPropertiesKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    maxMultiviewViewCount: uint32_t;
    maxMultiviewInstanceIndex: uint32_t;
  end;

  TVkRenderPassMultiviewCreateInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    subpassCount: uint32_t;
    pViewMasks: Puint32_t;
    dependencyCount: uint32_t;
    pViewOffsets: Pint32_t;
    correlationMaskCount: uint32_t;
    pCorrelationMasks: Puint32_t;
  end;

  TVkSurfaceCapabilities2EXT = record
    sType: TVkStructureType;
    pNext: Pointer;
    minImageCount: uint32_t;
    maxImageCount: uint32_t;
    currentExtent: TVkExtent2D;
    minImageExtent: TVkExtent2D;
    maxImageExtent: TVkExtent2D;
    maxImageArrayLayers: uint32_t;
    supportedTransforms: TVkSurfaceTransformFlagsKHR;
    currentTransform: TVkSurfaceTransformFlagBitsKHR;
    supportedCompositeAlpha: TVkCompositeAlphaFlagsKHR;
    supportedUsageFlags: TVkImageUsageFlags;
    supportedSurfaceCounters: TVkSurfaceCounterFlagsEXT;
  end;
  PVkSurfaceCapabilities2EXT = ^TVkSurfaceCapabilities2EXT;

  TVkDisplayPowerInfoEXT = record
    sType: TVkStructureType;
    pNext: Pointer;
    powerState: TVkDisplayPowerStateEXT;
  end;
  PVkDisplayPowerInfoEXT = ^TVkDisplayPowerInfoEXT;

  TVkDeviceEventInfoEXT = record
    sType: TVkStructureType;
    pNext: Pointer;
    deviceEvent: TVkDeviceEventTypeEXT;
  end;
  PVkDeviceEventInfoEXT = ^TVkDeviceEventInfoEXT;

  TVkDisplayEventInfoEXT = record
    sType: TVkStructureType;
    pNext: Pointer;
    displayEvent: TVkDisplayEventTypeEXT;
  end;
  PVkDisplayEventInfoEXT = ^TVkDisplayEventInfoEXT;

  TVkSwapchainCounterCreateInfoEXT = record
    sType: TVkStructureType;
    pNext: Pointer;
    surfaceCounters: TVkSurfaceCounterFlagsEXT;
  end;

  TVkPhysicalDeviceGroupPropertiesKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    physicalDeviceCount: uint32_t;
    physicalDevices: array[0..(VK_MAX_DEVICE_GROUP_SIZE_KHX - 1)] of TVkPhysicalDevice;
    subsetAllocation: TVkBool32;
  end;
  PVkPhysicalDeviceGroupPropertiesKHX = ^TVkPhysicalDeviceGroupPropertiesKHX;

  TVkMemoryAllocateFlagsInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkMemoryAllocateFlagsKHX;
    deviceMask: uint32_t;
  end;

  TVkBindBufferMemoryInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    buffer: TVkBuffer;
    memory: TVkDeviceMemory;
    memoryOffset: TVkDeviceSize;
    deviceIndexCount: uint32_t;
    pDeviceIndices: Puint32_t;
  end;
  PVkBindBufferMemoryInfoKHX = ^TVkBindBufferMemoryInfoKHX;

  TVkBindImageMemoryInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    image: TVkImage;
    memory: TVkDeviceMemory;
    memoryOffset: TVkDeviceSize;
    deviceIndexCount: uint32_t;
    pDeviceIndices: Puint32_t;
    SFRRectCount: uint32_t;
    pSFRRects: PVkRect2D;
  end;
  PVkBindImageMemoryInfoKHX = ^TVkBindImageMemoryInfoKHX;

  TVkDeviceGroupRenderPassBeginInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    deviceMask: uint32_t;
    deviceRenderAreaCount: uint32_t;
    pDeviceRenderAreas: PVkRect2D;
  end;

  TVkDeviceGroupCommandBufferBeginInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    deviceMask: uint32_t;
  end;

  TVkDeviceGroupSubmitInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    waitSemaphoreCount: uint32_t;
    pWaitSemaphoreDeviceIndices: Puint32_t;
    commandBufferCount: uint32_t;
    pCommandBufferDeviceMasks: Puint32_t;
    signalSemaphoreCount: uint32_t;
    pSignalSemaphoreDeviceIndices: Puint32_t;
  end;

  TVkDeviceGroupBindSparseInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    resourceDeviceIndex: uint32_t;
    memoryDeviceIndex: uint32_t;
  end;

  TVkDeviceGroupPresentCapabilitiesKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    presentMask: array[0..(VK_MAX_DEVICE_GROUP_SIZE_KHX - 1)] of uint32_t;
    modes: TVkDeviceGroupPresentModeFlagsKHX;
  end;
  PVkDeviceGroupPresentCapabilitiesKHX = ^TVkDeviceGroupPresentCapabilitiesKHX;

  TVkImageSwapchainCreateInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    swapchain: TVkSwapchainKHR;
  end;

  TVkBindImageMemorySwapchainInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    swapchain: TVkSwapchainKHR;
    imageIndex: uint32_t;
  end;

  TVkAcquireNextImageInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    swapchain: TVkSwapchainKHR;
    timeout: uint64_t;
    semaphore: TVkSemaphore;
    fence: TVkFence;
    deviceMask: uint32_t;
  end;
  PVkAcquireNextImageInfoKHX = ^TVkAcquireNextImageInfoKHX;

  TVkDeviceGroupPresentInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    swapchainCount: uint32_t;
    pDeviceMasks: Puint32_t;
    mode: TVkDeviceGroupPresentModeFlagBitsKHX;
  end;

  TVkDeviceGroupDeviceCreateInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    physicalDeviceCount: uint32_t;
    pPhysicalDevices: PVkPhysicalDevice;
  end;

  TVkDeviceGroupSwapchainCreateInfoKHX = record
    sType: TVkStructureType;
    pNext: Pointer;
    modes: TVkDeviceGroupPresentModeFlagsKHX;
  end;

  TVkDescriptorUpdateTemplateEntryKHR = record
    dstBinding: uint32_t;
    dstArrayElement: uint32_t;
    descriptorCount: uint32_t;
    descriptorType: TVkDescriptorType;
    offset: size_t;
    stride: size_t;
  end;
  PVkDescriptorUpdateTemplateEntryKHR = ^TVkDescriptorUpdateTemplateEntryKHR;

  TVkDescriptorUpdateTemplateCreateInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkDescriptorUpdateTemplateCreateFlagsKHR;
    descriptorUpdateEntryCount: uint32_t;
    pDescriptorUpdateEntries: PVkDescriptorUpdateTemplateEntryKHR;
    templateType: TVkDescriptorUpdateTemplateTypeKHR;
    descriptorSetLayout: TVkDescriptorSetLayout;
    pipelineBindPoint: TVkPipelineBindPoint;
    pipelineLayout: TVkPipelineLayout;
    set_: uint32_t;
  end;
  PVkDescriptorUpdateTemplateCreateInfoKHR = ^TVkDescriptorUpdateTemplateCreateInfoKHR;

  TVkXYColorEXT = record
    x: float;
    y: float;
  end;

  TVkHdrMetadataEXT = record
    sType: TVkStructureType;
    pNext: Pointer;
    displayPrimaryRed: TVkXYColorEXT;
    displayPrimaryGreen: TVkXYColorEXT;
    displayPrimaryBlue: TVkXYColorEXT;
    whitePoint: TVkXYColorEXT;
    maxLuminance: float;
    minLuminance: float;
    maxContentLightLevel: float;
    maxFrameAverageLightLevel: float;
  end;
  PVkHdrMetadataEXT = ^TVkHdrMetadataEXT;

  TVkRefreshCycleDurationGOOGLE = record
    refreshDuration: uint64_t;
  end;
  PVkRefreshCycleDurationGOOGLE = ^TVkRefreshCycleDurationGOOGLE;

  TVkPastPresentationTimingGOOGLE = record
    presentID: uint32_t;
    desiredPresentTime: uint64_t;
    actualPresentTime: uint64_t;
    earliestPresentTime: uint64_t;
    presentMargin: uint64_t;
  end;
  PVkPastPresentationTimingGOOGLE = ^TVkPastPresentationTimingGOOGLE;

  TVkPresentTimeGOOGLE = record
    presentID: uint32_t;
    desiredPresentTime: uint64_t;
  end;
  PVkPresentTimeGOOGLE = ^TVkPresentTimeGOOGLE;

  TVkPresentTimesInfoGOOGLE = record
    sType: TVkStructureType;
    pNext: Pointer;
    swapchainCount: uint32_t;
    pTimes: PVkPresentTimeGOOGLE;
  end;

{$IFDEF VK_USE_PLATFORM_IOS_MVK}
  TVkIOSSurfaceCreateInfoMVK = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkIOSSurfaceCreateFlagsMVK;
    pView: Pointer;
  end;
  PVkIOSSurfaceCreateInfoMVK = ^TVkIOSSurfaceCreateInfoMVK;
{$ENDIF VK_USE_PLATFORM_IOS_MVK}

{$IFDEF VK_USE_PLATFORM_MACOS_MVK}
  TVkMacOSSurfaceCreateInfoMVK = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkMacOSSurfaceCreateFlagsMVK;
    pView: Pointer;
  end;
  PVkMacOSSurfaceCreateInfoMVK = ^TVkMacOSSurfaceCreateInfoMVK;
{$ENDIF VK_USE_PLATFORM_MACOS_MVK}

  TVkViewportWScalingNV = record
    xcoeff: float;
    ycoeff: float;
  end;
  PVkViewportWScalingNV = ^TVkViewportWScalingNV;

  TVkPipelineViewportWScalingStateCreateInfoNV = record
    sType: TVkStructureType;
    pNext: Pointer;
    viewportWScalingEnable: TVkBool32;
    viewportCount: uint32_t;
    pViewportWScalings: PVkViewportWScalingNV;
  end;

  TVkViewportSwizzleNV = record
    x: TVkViewportCoordinateSwizzleNV;
    y: TVkViewportCoordinateSwizzleNV;
    z: TVkViewportCoordinateSwizzleNV;
    w: TVkViewportCoordinateSwizzleNV;
  end;
  PVkViewportSwizzleNV = ^TVkViewportSwizzleNV;

  TVkPipelineViewportSwizzleStateCreateInfoNV = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineViewportSwizzleStateCreateFlagsNV;
    viewportCount: uint32_t;
    pViewportSwizzles: PVkViewportSwizzleNV;
  end;

  TVkPhysicalDeviceDiscardRectanglePropertiesEXT = record
    sType: TVkStructureType;
    pNext: Pointer;
    maxDiscardRectangles: uint32_t;
  end;

  TVkPipelineDiscardRectangleStateCreateInfoEXT = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineDiscardRectangleStateCreateFlagsEXT;
    discardRectangleMode: TVkDiscardRectangleModeEXT;
    discardRectangleCount: uint32_t;
    pDiscardRectangles: PVkRect2D;
  end;

  TVkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = record
    sType: TVkStructureType;
    pNext: Pointer;
    perViewPositionAllComponents: TVkBool32;
  end;


    { SECTION: Vulkan command definitions }


  TvkCreateInstance = function(
    pCreateInfo: PVkInstanceCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pInstance: PVkInstance
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyInstance = procedure(
    instance: TVkInstance;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkEnumeratePhysicalDevices = function(
    instance: TVkInstance;
    pPhysicalDeviceCount: Puint32_t;
    pPhysicalDevices: PVkPhysicalDevice
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDeviceProcAddr = function(
    device: TVkDevice;
    pName: Pchar
  ): TPFN_vkVoidFunction; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetInstanceProcAddr = function(
    instance: TVkInstance;
    pName: Pchar
  ): TPFN_vkVoidFunction; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceProperties = procedure(
    physicalDevice: TVkPhysicalDevice;
    pProperties: PVkPhysicalDeviceProperties
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceQueueFamilyProperties = procedure(
    physicalDevice: TVkPhysicalDevice;
    pQueueFamilyPropertyCount: Puint32_t;
    pQueueFamilyProperties: PVkQueueFamilyProperties
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceMemoryProperties = procedure(
    physicalDevice: TVkPhysicalDevice;
    pMemoryProperties: PVkPhysicalDeviceMemoryProperties
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceFeatures = procedure(
    physicalDevice: TVkPhysicalDevice;
    pFeatures: PVkPhysicalDeviceFeatures
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceFormatProperties = procedure(
    physicalDevice: TVkPhysicalDevice;
    format: TVkFormat;
    pFormatProperties: PVkFormatProperties
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceImageFormatProperties = function(
    physicalDevice: TVkPhysicalDevice;
    format: TVkFormat;
    type_: TVkImageType;
    tiling: TVkImageTiling;
    usage: TVkImageUsageFlags;
    flags: TVkImageCreateFlags;
    pImageFormatProperties: PVkImageFormatProperties
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateDevice = function(
    physicalDevice: TVkPhysicalDevice;
    pCreateInfo: PVkDeviceCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pDevice: PVkDevice
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyDevice = procedure(
    device: TVkDevice;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkEnumerateInstanceLayerProperties = function(
    pPropertyCount: Puint32_t;
    pProperties: PVkLayerProperties
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkEnumerateInstanceExtensionProperties = function(
    pLayerName: Pchar;
    pPropertyCount: Puint32_t;
    pProperties: PVkExtensionProperties
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkEnumerateDeviceLayerProperties = function(
    physicalDevice: TVkPhysicalDevice;
    pPropertyCount: Puint32_t;
    pProperties: PVkLayerProperties
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkEnumerateDeviceExtensionProperties = function(
    physicalDevice: TVkPhysicalDevice;
    pLayerName: Pchar;
    pPropertyCount: Puint32_t;
    pProperties: PVkExtensionProperties
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDeviceQueue = procedure(
    device: TVkDevice;
    queueFamilyIndex: uint32_t;
    queueIndex: uint32_t;
    pQueue: PVkQueue
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkQueueSubmit = function(
    queue: TVkQueue;
    submitCount: uint32_t;
    pSubmits: PVkSubmitInfo;
    fence: TVkFence
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkQueueWaitIdle = function(
    queue: TVkQueue
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDeviceWaitIdle = function(
    device: TVkDevice
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkAllocateMemory = function(
    device: TVkDevice;
    pAllocateInfo: PVkMemoryAllocateInfo;
    pAllocator: PVkAllocationCallbacks;
    pMemory: PVkDeviceMemory
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkFreeMemory = procedure(
    device: TVkDevice;
    memory: TVkDeviceMemory;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkMapMemory = function(
    device: TVkDevice;
    memory: TVkDeviceMemory;
    offset: TVkDeviceSize;
    size: TVkDeviceSize;
    flags: TVkMemoryMapFlags;
    ppData: PPointer
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkUnmapMemory = procedure(
    device: TVkDevice;
    memory: TVkDeviceMemory
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkFlushMappedMemoryRanges = function(
    device: TVkDevice;
    memoryRangeCount: uint32_t;
    pMemoryRanges: PVkMappedMemoryRange
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkInvalidateMappedMemoryRanges = function(
    device: TVkDevice;
    memoryRangeCount: uint32_t;
    pMemoryRanges: PVkMappedMemoryRange
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDeviceMemoryCommitment = procedure(
    device: TVkDevice;
    memory: TVkDeviceMemory;
    pCommittedMemoryInBytes: PVkDeviceSize
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetBufferMemoryRequirements = procedure(
    device: TVkDevice;
    buffer: TVkBuffer;
    pMemoryRequirements: PVkMemoryRequirements
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkBindBufferMemory = function(
    device: TVkDevice;
    buffer: TVkBuffer;
    memory: TVkDeviceMemory;
    memoryOffset: TVkDeviceSize
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetImageMemoryRequirements = procedure(
    device: TVkDevice;
    image: TVkImage;
    pMemoryRequirements: PVkMemoryRequirements
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkBindImageMemory = function(
    device: TVkDevice;
    image: TVkImage;
    memory: TVkDeviceMemory;
    memoryOffset: TVkDeviceSize
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetImageSparseMemoryRequirements = procedure(
    device: TVkDevice;
    image: TVkImage;
    pSparseMemoryRequirementCount: Puint32_t;
    pSparseMemoryRequirements: PVkSparseImageMemoryRequirements
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceSparseImageFormatProperties = procedure(
    physicalDevice: TVkPhysicalDevice;
    format: TVkFormat;
    type_: TVkImageType;
    samples: TVkSampleCountFlagBits;
    usage: TVkImageUsageFlags;
    tiling: TVkImageTiling;
    pPropertyCount: Puint32_t;
    pProperties: PVkSparseImageFormatProperties
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkQueueBindSparse = function(
    queue: TVkQueue;
    bindInfoCount: uint32_t;
    pBindInfo: PVkBindSparseInfo;
    fence: TVkFence
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateFence = function(
    device: TVkDevice;
    pCreateInfo: PVkFenceCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pFence: PVkFence
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyFence = procedure(
    device: TVkDevice;
    fence: TVkFence;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkResetFences = function(
    device: TVkDevice;
    fenceCount: uint32_t;
    pFences: PVkFence
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetFenceStatus = function(
    device: TVkDevice;
    fence: TVkFence
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkWaitForFences = function(
    device: TVkDevice;
    fenceCount: uint32_t;
    pFences: PVkFence;
    waitAll: TVkBool32;
    timeout: uint64_t
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateSemaphore = function(
    device: TVkDevice;
    pCreateInfo: PVkSemaphoreCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pSemaphore: PVkSemaphore
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroySemaphore = procedure(
    device: TVkDevice;
    semaphore: TVkSemaphore;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateEvent = function(
    device: TVkDevice;
    pCreateInfo: PVkEventCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pEvent: PVkEvent
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyEvent = procedure(
    device: TVkDevice;
    event: TVkEvent;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetEventStatus = function(
    device: TVkDevice;
    event: TVkEvent
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkSetEvent = function(
    device: TVkDevice;
    event: TVkEvent
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkResetEvent = function(
    device: TVkDevice;
    event: TVkEvent
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateQueryPool = function(
    device: TVkDevice;
    pCreateInfo: PVkQueryPoolCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pQueryPool: PVkQueryPool
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyQueryPool = procedure(
    device: TVkDevice;
    queryPool: TVkQueryPool;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetQueryPoolResults = function(
    device: TVkDevice;
    queryPool: TVkQueryPool;
    firstQuery: uint32_t;
    queryCount: uint32_t;
    dataSize: size_t;
    pData: Pointer;
    stride: TVkDeviceSize;
    flags: TVkQueryResultFlags
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateBuffer = function(
    device: TVkDevice;
    pCreateInfo: PVkBufferCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pBuffer: PVkBuffer
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyBuffer = procedure(
    device: TVkDevice;
    buffer: TVkBuffer;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateBufferView = function(
    device: TVkDevice;
    pCreateInfo: PVkBufferViewCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pView: PVkBufferView
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyBufferView = procedure(
    device: TVkDevice;
    bufferView: TVkBufferView;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateImage = function(
    device: TVkDevice;
    pCreateInfo: PVkImageCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pImage: PVkImage
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyImage = procedure(
    device: TVkDevice;
    image: TVkImage;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetImageSubresourceLayout = procedure(
    device: TVkDevice;
    image: TVkImage;
    pSubresource: PVkImageSubresource;
    pLayout: PVkSubresourceLayout
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateImageView = function(
    device: TVkDevice;
    pCreateInfo: PVkImageViewCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pView: PVkImageView
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyImageView = procedure(
    device: TVkDevice;
    imageView: TVkImageView;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateShaderModule = function(
    device: TVkDevice;
    pCreateInfo: PVkShaderModuleCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pShaderModule: PVkShaderModule
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyShaderModule = procedure(
    device: TVkDevice;
    shaderModule: TVkShaderModule;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreatePipelineCache = function(
    device: TVkDevice;
    pCreateInfo: PVkPipelineCacheCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pPipelineCache: PVkPipelineCache
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyPipelineCache = procedure(
    device: TVkDevice;
    pipelineCache: TVkPipelineCache;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPipelineCacheData = function(
    device: TVkDevice;
    pipelineCache: TVkPipelineCache;
    pDataSize: Psize_t;
    pData: Pointer
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkMergePipelineCaches = function(
    device: TVkDevice;
    dstCache: TVkPipelineCache;
    srcCacheCount: uint32_t;
    pSrcCaches: PVkPipelineCache
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateGraphicsPipelines = function(
    device: TVkDevice;
    pipelineCache: TVkPipelineCache;
    createInfoCount: uint32_t;
    pCreateInfos: PVkGraphicsPipelineCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pPipelines: PVkPipeline
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateComputePipelines = function(
    device: TVkDevice;
    pipelineCache: TVkPipelineCache;
    createInfoCount: uint32_t;
    pCreateInfos: PVkComputePipelineCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pPipelines: PVkPipeline
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyPipeline = procedure(
    device: TVkDevice;
    pipeline: TVkPipeline;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreatePipelineLayout = function(
    device: TVkDevice;
    pCreateInfo: PVkPipelineLayoutCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pPipelineLayout: PVkPipelineLayout
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyPipelineLayout = procedure(
    device: TVkDevice;
    pipelineLayout: TVkPipelineLayout;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateSampler = function(
    device: TVkDevice;
    pCreateInfo: PVkSamplerCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pSampler: PVkSampler
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroySampler = procedure(
    device: TVkDevice;
    sampler: TVkSampler;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateDescriptorSetLayout = function(
    device: TVkDevice;
    pCreateInfo: PVkDescriptorSetLayoutCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pSetLayout: PVkDescriptorSetLayout
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyDescriptorSetLayout = procedure(
    device: TVkDevice;
    descriptorSetLayout: TVkDescriptorSetLayout;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateDescriptorPool = function(
    device: TVkDevice;
    pCreateInfo: PVkDescriptorPoolCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pDescriptorPool: PVkDescriptorPool
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyDescriptorPool = procedure(
    device: TVkDevice;
    descriptorPool: TVkDescriptorPool;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkResetDescriptorPool = function(
    device: TVkDevice;
    descriptorPool: TVkDescriptorPool;
    flags: TVkDescriptorPoolResetFlags
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkAllocateDescriptorSets = function(
    device: TVkDevice;
    pAllocateInfo: PVkDescriptorSetAllocateInfo;
    pDescriptorSets: PVkDescriptorSet
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkFreeDescriptorSets = function(
    device: TVkDevice;
    descriptorPool: TVkDescriptorPool;
    descriptorSetCount: uint32_t;
    pDescriptorSets: PVkDescriptorSet
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkUpdateDescriptorSets = procedure(
    device: TVkDevice;
    descriptorWriteCount: uint32_t;
    pDescriptorWrites: PVkWriteDescriptorSet;
    descriptorCopyCount: uint32_t;
    pDescriptorCopies: PVkCopyDescriptorSet
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateFramebuffer = function(
    device: TVkDevice;
    pCreateInfo: PVkFramebufferCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pFramebuffer: PVkFramebuffer
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyFramebuffer = procedure(
    device: TVkDevice;
    framebuffer: TVkFramebuffer;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateRenderPass = function(
    device: TVkDevice;
    pCreateInfo: PVkRenderPassCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pRenderPass: PVkRenderPass
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyRenderPass = procedure(
    device: TVkDevice;
    renderPass: TVkRenderPass;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetRenderAreaGranularity = procedure(
    device: TVkDevice;
    renderPass: TVkRenderPass;
    pGranularity: PVkExtent2D
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateCommandPool = function(
    device: TVkDevice;
    pCreateInfo: PVkCommandPoolCreateInfo;
    pAllocator: PVkAllocationCallbacks;
    pCommandPool: PVkCommandPool
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyCommandPool = procedure(
    device: TVkDevice;
    commandPool: TVkCommandPool;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkResetCommandPool = function(
    device: TVkDevice;
    commandPool: TVkCommandPool;
    flags: TVkCommandPoolResetFlags
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkAllocateCommandBuffers = function(
    device: TVkDevice;
    pAllocateInfo: PVkCommandBufferAllocateInfo;
    pCommandBuffers: PVkCommandBuffer
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkFreeCommandBuffers = procedure(
    device: TVkDevice;
    commandPool: TVkCommandPool;
    commandBufferCount: uint32_t;
    pCommandBuffers: PVkCommandBuffer
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkBeginCommandBuffer = function(
    commandBuffer: TVkCommandBuffer;
    pBeginInfo: PVkCommandBufferBeginInfo
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkEndCommandBuffer = function(
    commandBuffer: TVkCommandBuffer
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkResetCommandBuffer = function(
    commandBuffer: TVkCommandBuffer;
    flags: TVkCommandBufferResetFlags
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBindPipeline = procedure(
    commandBuffer: TVkCommandBuffer;
    pipelineBindPoint: TVkPipelineBindPoint;
    pipeline: TVkPipeline
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetViewport = procedure(
    commandBuffer: TVkCommandBuffer;
    firstViewport: uint32_t;
    viewportCount: uint32_t;
    pViewports: PVkViewport
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetScissor = procedure(
    commandBuffer: TVkCommandBuffer;
    firstScissor: uint32_t;
    scissorCount: uint32_t;
    pScissors: PVkRect2D
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetLineWidth = procedure(
    commandBuffer: TVkCommandBuffer;
    lineWidth: float
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetDepthBias = procedure(
    commandBuffer: TVkCommandBuffer;
    depthBiasConstantFactor: float;
    depthBiasClamp: float;
    depthBiasSlopeFactor: float
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetBlendConstants = procedure(
    commandBuffer: TVkCommandBuffer;
    blendConstants: Tfloat_0_3
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetDepthBounds = procedure(
    commandBuffer: TVkCommandBuffer;
    minDepthBounds: float;
    maxDepthBounds: float
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetStencilCompareMask = procedure(
    commandBuffer: TVkCommandBuffer;
    faceMask: TVkStencilFaceFlags;
    compareMask: uint32_t
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetStencilWriteMask = procedure(
    commandBuffer: TVkCommandBuffer;
    faceMask: TVkStencilFaceFlags;
    writeMask: uint32_t
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetStencilReference = procedure(
    commandBuffer: TVkCommandBuffer;
    faceMask: TVkStencilFaceFlags;
    reference: uint32_t
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBindDescriptorSets = procedure(
    commandBuffer: TVkCommandBuffer;
    pipelineBindPoint: TVkPipelineBindPoint;
    layout: TVkPipelineLayout;
    firstSet: uint32_t;
    descriptorSetCount: uint32_t;
    pDescriptorSets: PVkDescriptorSet;
    dynamicOffsetCount: uint32_t;
    pDynamicOffsets: Puint32_t
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBindIndexBuffer = procedure(
    commandBuffer: TVkCommandBuffer;
    buffer: TVkBuffer;
    offset: TVkDeviceSize;
    indexType: TVkIndexType
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBindVertexBuffers = procedure(
    commandBuffer: TVkCommandBuffer;
    firstBinding: uint32_t;
    bindingCount: uint32_t;
    pBuffers: PVkBuffer;
    pOffsets: PVkDeviceSize
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDraw = procedure(
    commandBuffer: TVkCommandBuffer;
    vertexCount: uint32_t;
    instanceCount: uint32_t;
    firstVertex: uint32_t;
    firstInstance: uint32_t
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDrawIndexed = procedure(
    commandBuffer: TVkCommandBuffer;
    indexCount: uint32_t;
    instanceCount: uint32_t;
    firstIndex: uint32_t;
    vertexOffset: int32_t;
    firstInstance: uint32_t
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDrawIndirect = procedure(
    commandBuffer: TVkCommandBuffer;
    buffer: TVkBuffer;
    offset: TVkDeviceSize;
    drawCount: uint32_t;
    stride: uint32_t
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDrawIndexedIndirect = procedure(
    commandBuffer: TVkCommandBuffer;
    buffer: TVkBuffer;
    offset: TVkDeviceSize;
    drawCount: uint32_t;
    stride: uint32_t
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDispatch = procedure(
    commandBuffer: TVkCommandBuffer;
    groupCountX: uint32_t;
    groupCountY: uint32_t;
    groupCountZ: uint32_t
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDispatchIndirect = procedure(
    commandBuffer: TVkCommandBuffer;
    buffer: TVkBuffer;
    offset: TVkDeviceSize
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdCopyBuffer = procedure(
    commandBuffer: TVkCommandBuffer;
    srcBuffer: TVkBuffer;
    dstBuffer: TVkBuffer;
    regionCount: uint32_t;
    pRegions: PVkBufferCopy
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdCopyImage = procedure(
    commandBuffer: TVkCommandBuffer;
    srcImage: TVkImage;
    srcImageLayout: TVkImageLayout;
    dstImage: TVkImage;
    dstImageLayout: TVkImageLayout;
    regionCount: uint32_t;
    pRegions: PVkImageCopy
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBlitImage = procedure(
    commandBuffer: TVkCommandBuffer;
    srcImage: TVkImage;
    srcImageLayout: TVkImageLayout;
    dstImage: TVkImage;
    dstImageLayout: TVkImageLayout;
    regionCount: uint32_t;
    pRegions: PVkImageBlit;
    filter: TVkFilter
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdCopyBufferToImage = procedure(
    commandBuffer: TVkCommandBuffer;
    srcBuffer: TVkBuffer;
    dstImage: TVkImage;
    dstImageLayout: TVkImageLayout;
    regionCount: uint32_t;
    pRegions: PVkBufferImageCopy
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdCopyImageToBuffer = procedure(
    commandBuffer: TVkCommandBuffer;
    srcImage: TVkImage;
    srcImageLayout: TVkImageLayout;
    dstBuffer: TVkBuffer;
    regionCount: uint32_t;
    pRegions: PVkBufferImageCopy
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdUpdateBuffer = procedure(
    commandBuffer: TVkCommandBuffer;
    dstBuffer: TVkBuffer;
    dstOffset: TVkDeviceSize;
    dataSize: TVkDeviceSize;
    pData: Pointer
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdFillBuffer = procedure(
    commandBuffer: TVkCommandBuffer;
    dstBuffer: TVkBuffer;
    dstOffset: TVkDeviceSize;
    size: TVkDeviceSize;
    data: uint32_t
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdClearColorImage = procedure(
    commandBuffer: TVkCommandBuffer;
    image: TVkImage;
    imageLayout: TVkImageLayout;
    pColor: PVkClearColorValue;
    rangeCount: uint32_t;
    pRanges: PVkImageSubresourceRange
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdClearDepthStencilImage = procedure(
    commandBuffer: TVkCommandBuffer;
    image: TVkImage;
    imageLayout: TVkImageLayout;
    pDepthStencil: PVkClearDepthStencilValue;
    rangeCount: uint32_t;
    pRanges: PVkImageSubresourceRange
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdClearAttachments = procedure(
    commandBuffer: TVkCommandBuffer;
    attachmentCount: uint32_t;
    pAttachments: PVkClearAttachment;
    rectCount: uint32_t;
    pRects: PVkClearRect
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdResolveImage = procedure(
    commandBuffer: TVkCommandBuffer;
    srcImage: TVkImage;
    srcImageLayout: TVkImageLayout;
    dstImage: TVkImage;
    dstImageLayout: TVkImageLayout;
    regionCount: uint32_t;
    pRegions: PVkImageResolve
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetEvent = procedure(
    commandBuffer: TVkCommandBuffer;
    event: TVkEvent;
    stageMask: TVkPipelineStageFlags
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdResetEvent = procedure(
    commandBuffer: TVkCommandBuffer;
    event: TVkEvent;
    stageMask: TVkPipelineStageFlags
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdWaitEvents = procedure(
    commandBuffer: TVkCommandBuffer;
    eventCount: uint32_t;
    pEvents: PVkEvent;
    srcStageMask: TVkPipelineStageFlags;
    dstStageMask: TVkPipelineStageFlags;
    memoryBarrierCount: uint32_t;
    pMemoryBarriers: PVkMemoryBarrier;
    bufferMemoryBarrierCount: uint32_t;
    pBufferMemoryBarriers: PVkBufferMemoryBarrier;
    imageMemoryBarrierCount: uint32_t;
    pImageMemoryBarriers: PVkImageMemoryBarrier
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdPipelineBarrier = procedure(
    commandBuffer: TVkCommandBuffer;
    srcStageMask: TVkPipelineStageFlags;
    dstStageMask: TVkPipelineStageFlags;
    dependencyFlags: TVkDependencyFlags;
    memoryBarrierCount: uint32_t;
    pMemoryBarriers: PVkMemoryBarrier;
    bufferMemoryBarrierCount: uint32_t;
    pBufferMemoryBarriers: PVkBufferMemoryBarrier;
    imageMemoryBarrierCount: uint32_t;
    pImageMemoryBarriers: PVkImageMemoryBarrier
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBeginQuery = procedure(
    commandBuffer: TVkCommandBuffer;
    queryPool: TVkQueryPool;
    query: uint32_t;
    flags: TVkQueryControlFlags
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdEndQuery = procedure(
    commandBuffer: TVkCommandBuffer;
    queryPool: TVkQueryPool;
    query: uint32_t
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdResetQueryPool = procedure(
    commandBuffer: TVkCommandBuffer;
    queryPool: TVkQueryPool;
    firstQuery: uint32_t;
    queryCount: uint32_t
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdWriteTimestamp = procedure(
    commandBuffer: TVkCommandBuffer;
    pipelineStage: TVkPipelineStageFlagBits;
    queryPool: TVkQueryPool;
    query: uint32_t
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdCopyQueryPoolResults = procedure(
    commandBuffer: TVkCommandBuffer;
    queryPool: TVkQueryPool;
    firstQuery: uint32_t;
    queryCount: uint32_t;
    dstBuffer: TVkBuffer;
    dstOffset: TVkDeviceSize;
    stride: TVkDeviceSize;
    flags: TVkQueryResultFlags
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdPushConstants = procedure(
    commandBuffer: TVkCommandBuffer;
    layout: TVkPipelineLayout;
    stageFlags: TVkShaderStageFlags;
    offset: uint32_t;
    size: uint32_t;
    pValues: Pointer
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBeginRenderPass = procedure(
    commandBuffer: TVkCommandBuffer;
    pRenderPassBegin: PVkRenderPassBeginInfo;
    contents: TVkSubpassContents
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdNextSubpass = procedure(
    commandBuffer: TVkCommandBuffer;
    contents: TVkSubpassContents
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdEndRenderPass = procedure(
    commandBuffer: TVkCommandBuffer
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdExecuteCommands = procedure(
    commandBuffer: TVkCommandBuffer;
    commandBufferCount: uint32_t;
    pCommandBuffers: PVkCommandBuffer
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{$IFDEF VK_USE_PLATFORM_ANDROID_KHR}
  TvkCreateAndroidSurfaceKHR = function(
    instance: TVkInstance;
    pCreateInfo: PVkAndroidSurfaceCreateInfoKHR;
    pAllocator: PVkAllocationCallbacks;
    pSurface: PVkSurfaceKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_ANDROID_KHR}

  TvkGetPhysicalDeviceDisplayPropertiesKHR = function(
    physicalDevice: TVkPhysicalDevice;
    pPropertyCount: Puint32_t;
    pProperties: PVkDisplayPropertiesKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceDisplayPlanePropertiesKHR = function(
    physicalDevice: TVkPhysicalDevice;
    pPropertyCount: Puint32_t;
    pProperties: PVkDisplayPlanePropertiesKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDisplayPlaneSupportedDisplaysKHR = function(
    physicalDevice: TVkPhysicalDevice;
    planeIndex: uint32_t;
    pDisplayCount: Puint32_t;
    pDisplays: PVkDisplayKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDisplayModePropertiesKHR = function(
    physicalDevice: TVkPhysicalDevice;
    display: TVkDisplayKHR;
    pPropertyCount: Puint32_t;
    pProperties: PVkDisplayModePropertiesKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateDisplayModeKHR = function(
    physicalDevice: TVkPhysicalDevice;
    display: TVkDisplayKHR;
    pCreateInfo: PVkDisplayModeCreateInfoKHR;
    pAllocator: PVkAllocationCallbacks;
    pMode: PVkDisplayModeKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDisplayPlaneCapabilitiesKHR = function(
    physicalDevice: TVkPhysicalDevice;
    mode: TVkDisplayModeKHR;
    planeIndex: uint32_t;
    pCapabilities: PVkDisplayPlaneCapabilitiesKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateDisplayPlaneSurfaceKHR = function(
    instance: TVkInstance;
    pCreateInfo: PVkDisplaySurfaceCreateInfoKHR;
    pAllocator: PVkAllocationCallbacks;
    pSurface: PVkSurfaceKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateSharedSwapchainsKHR = function(
    device: TVkDevice;
    swapchainCount: uint32_t;
    pCreateInfos: PVkSwapchainCreateInfoKHR;
    pAllocator: PVkAllocationCallbacks;
    pSwapchains: PVkSwapchainKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{$IFDEF VK_USE_PLATFORM_MIR_KHR}
  TvkCreateMirSurfaceKHR = function(
    instance: TVkInstance;
    pCreateInfo: PVkMirSurfaceCreateInfoKHR;
    pAllocator: PVkAllocationCallbacks;
    pSurface: PVkSurfaceKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_MIR_KHR}

{$IFDEF VK_USE_PLATFORM_MIR_KHR}
  TvkGetPhysicalDeviceMirPresentationSupportKHR = function(
    physicalDevice: TVkPhysicalDevice;
    queueFamilyIndex: uint32_t;
    connection: PMirConnection
  ): TVkBool32; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_MIR_KHR}

  TvkDestroySurfaceKHR = procedure(
    instance: TVkInstance;
    surface: TVkSurfaceKHR;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceSurfaceSupportKHR = function(
    physicalDevice: TVkPhysicalDevice;
    queueFamilyIndex: uint32_t;
    surface: TVkSurfaceKHR;
    pSupported: PVkBool32
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceSurfaceCapabilitiesKHR = function(
    physicalDevice: TVkPhysicalDevice;
    surface: TVkSurfaceKHR;
    pSurfaceCapabilities: PVkSurfaceCapabilitiesKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceSurfaceFormatsKHR = function(
    physicalDevice: TVkPhysicalDevice;
    surface: TVkSurfaceKHR;
    pSurfaceFormatCount: Puint32_t;
    pSurfaceFormats: PVkSurfaceFormatKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceSurfacePresentModesKHR = function(
    physicalDevice: TVkPhysicalDevice;
    surface: TVkSurfaceKHR;
    pPresentModeCount: Puint32_t;
    pPresentModes: PVkPresentModeKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateSwapchainKHR = function(
    device: TVkDevice;
    pCreateInfo: PVkSwapchainCreateInfoKHR;
    pAllocator: PVkAllocationCallbacks;
    pSwapchain: PVkSwapchainKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroySwapchainKHR = procedure(
    device: TVkDevice;
    swapchain: TVkSwapchainKHR;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetSwapchainImagesKHR = function(
    device: TVkDevice;
    swapchain: TVkSwapchainKHR;
    pSwapchainImageCount: Puint32_t;
    pSwapchainImages: PVkImage
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkAcquireNextImageKHR = function(
    device: TVkDevice;
    swapchain: TVkSwapchainKHR;
    timeout: uint64_t;
    semaphore: TVkSemaphore;
    fence: TVkFence;
    pImageIndex: Puint32_t
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkQueuePresentKHR = function(
    queue: TVkQueue;
    pPresentInfo: PVkPresentInfoKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{$IFDEF VK_USE_PLATFORM_VI_NN}
  TvkCreateViSurfaceNN = function(
    instance: TVkInstance;
    pCreateInfo: PVkViSurfaceCreateInfoNN;
    pAllocator: PVkAllocationCallbacks;
    pSurface: PVkSurfaceKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_VI_NN}

{$IFDEF VK_USE_PLATFORM_WAYLAND_KHR}
  TvkCreateWaylandSurfaceKHR = function(
    instance: TVkInstance;
    pCreateInfo: PVkWaylandSurfaceCreateInfoKHR;
    pAllocator: PVkAllocationCallbacks;
    pSurface: PVkSurfaceKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_WAYLAND_KHR}

{$IFDEF VK_USE_PLATFORM_WAYLAND_KHR}
  TvkGetPhysicalDeviceWaylandPresentationSupportKHR = function(
    physicalDevice: TVkPhysicalDevice;
    queueFamilyIndex: uint32_t;
    display: Pwl_display
  ): TVkBool32; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_WAYLAND_KHR}

{$IFDEF VK_USE_PLATFORM_WIN32_KHR}
  TvkCreateWin32SurfaceKHR = function(
    instance: TVkInstance;
    pCreateInfo: PVkWin32SurfaceCreateInfoKHR;
    pAllocator: PVkAllocationCallbacks;
    pSurface: PVkSurfaceKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_WIN32_KHR}

{$IFDEF VK_USE_PLATFORM_WIN32_KHR}
  TvkGetPhysicalDeviceWin32PresentationSupportKHR = function(
    physicalDevice: TVkPhysicalDevice;
    queueFamilyIndex: uint32_t
  ): TVkBool32; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_WIN32_KHR}

{$IFDEF VK_USE_PLATFORM_XLIB_KHR}
  TvkCreateXlibSurfaceKHR = function(
    instance: TVkInstance;
    pCreateInfo: PVkXlibSurfaceCreateInfoKHR;
    pAllocator: PVkAllocationCallbacks;
    pSurface: PVkSurfaceKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_XLIB_KHR}

{$IFDEF VK_USE_PLATFORM_XLIB_KHR}
  TvkGetPhysicalDeviceXlibPresentationSupportKHR = function(
    physicalDevice: TVkPhysicalDevice;
    queueFamilyIndex: uint32_t;
    dpy: PDisplay;
    visualID: TVisualID
  ): TVkBool32; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_XLIB_KHR}

{$IFDEF VK_USE_PLATFORM_XCB_KHR}
  TvkCreateXcbSurfaceKHR = function(
    instance: TVkInstance;
    pCreateInfo: PVkXcbSurfaceCreateInfoKHR;
    pAllocator: PVkAllocationCallbacks;
    pSurface: PVkSurfaceKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_XCB_KHR}

{$IFDEF VK_USE_PLATFORM_XCB_KHR}
  TvkGetPhysicalDeviceXcbPresentationSupportKHR = function(
    physicalDevice: TVkPhysicalDevice;
    queueFamilyIndex: uint32_t;
    connection: Pxcb_connection_t;
    visual_id: Txcb_visualid_t
  ): TVkBool32; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_XCB_KHR}

  TvkCreateDebugReportCallbackEXT = function(
    instance: TVkInstance;
    pCreateInfo: PVkDebugReportCallbackCreateInfoEXT;
    pAllocator: PVkAllocationCallbacks;
    pCallback: PVkDebugReportCallbackEXT
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyDebugReportCallbackEXT = procedure(
    instance: TVkInstance;
    callback: TVkDebugReportCallbackEXT;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDebugReportMessageEXT = procedure(
    instance: TVkInstance;
    flags: TVkDebugReportFlagsEXT;
    objectType: TVkDebugReportObjectTypeEXT;
    object_: uint64_t;
    location: size_t;
    messageCode: int32_t;
    pLayerPrefix: Pchar;
    pMessage: Pchar
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDebugMarkerSetObjectNameEXT = function(
    device: TVkDevice;
    pNameInfo: PVkDebugMarkerObjectNameInfoEXT
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDebugMarkerSetObjectTagEXT = function(
    device: TVkDevice;
    pTagInfo: PVkDebugMarkerObjectTagInfoEXT
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDebugMarkerBeginEXT = procedure(
    commandBuffer: TVkCommandBuffer;
    pMarkerInfo: PVkDebugMarkerMarkerInfoEXT
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDebugMarkerEndEXT = procedure(
    commandBuffer: TVkCommandBuffer
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDebugMarkerInsertEXT = procedure(
    commandBuffer: TVkCommandBuffer;
    pMarkerInfo: PVkDebugMarkerMarkerInfoEXT
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceExternalImageFormatPropertiesNV = function(
    physicalDevice: TVkPhysicalDevice;
    format: TVkFormat;
    type_: TVkImageType;
    tiling: TVkImageTiling;
    usage: TVkImageUsageFlags;
    flags: TVkImageCreateFlags;
    externalHandleType: TVkExternalMemoryHandleTypeFlagsNV;
    pExternalImageFormatProperties: PVkExternalImageFormatPropertiesNV
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{$IFDEF VK_USE_PLATFORM_WIN32_KHR}
  TvkGetMemoryWin32HandleNV = function(
    device: TVkDevice;
    memory: TVkDeviceMemory;
    handleType: TVkExternalMemoryHandleTypeFlagsNV;
    pHandle: PHANDLE
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_WIN32_KHR}

  TvkCmdDrawIndirectCountAMD = procedure(
    commandBuffer: TVkCommandBuffer;
    buffer: TVkBuffer;
    offset: TVkDeviceSize;
    countBuffer: TVkBuffer;
    countBufferOffset: TVkDeviceSize;
    maxDrawCount: uint32_t;
    stride: uint32_t
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDrawIndexedIndirectCountAMD = procedure(
    commandBuffer: TVkCommandBuffer;
    buffer: TVkBuffer;
    offset: TVkDeviceSize;
    countBuffer: TVkBuffer;
    countBufferOffset: TVkDeviceSize;
    maxDrawCount: uint32_t;
    stride: uint32_t
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdProcessCommandsNVX = procedure(
    commandBuffer: TVkCommandBuffer;
    pProcessCommandsInfo: PVkCmdProcessCommandsInfoNVX
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdReserveSpaceForCommandsNVX = procedure(
    commandBuffer: TVkCommandBuffer;
    pReserveSpaceInfo: PVkCmdReserveSpaceForCommandsInfoNVX
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateIndirectCommandsLayoutNVX = function(
    device: TVkDevice;
    pCreateInfo: PVkIndirectCommandsLayoutCreateInfoNVX;
    pAllocator: PVkAllocationCallbacks;
    pIndirectCommandsLayout: PVkIndirectCommandsLayoutNVX
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyIndirectCommandsLayoutNVX = procedure(
    device: TVkDevice;
    indirectCommandsLayout: TVkIndirectCommandsLayoutNVX;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateObjectTableNVX = function(
    device: TVkDevice;
    pCreateInfo: PVkObjectTableCreateInfoNVX;
    pAllocator: PVkAllocationCallbacks;
    pObjectTable: PVkObjectTableNVX
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyObjectTableNVX = procedure(
    device: TVkDevice;
    objectTable: TVkObjectTableNVX;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkRegisterObjectsNVX = function(
    device: TVkDevice;
    objectTable: TVkObjectTableNVX;
    objectCount: uint32_t;
    ppObjectTableEntries: PPVkObjectTableEntryNVX;
    pObjectIndices: Puint32_t
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkUnregisterObjectsNVX = function(
    device: TVkDevice;
    objectTable: TVkObjectTableNVX;
    objectCount: uint32_t;
    pObjectEntryTypes: PVkObjectEntryTypeNVX;
    pObjectIndices: Puint32_t
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceGeneratedCommandsPropertiesNVX = procedure(
    physicalDevice: TVkPhysicalDevice;
    pFeatures: PVkDeviceGeneratedCommandsFeaturesNVX;
    pLimits: PVkDeviceGeneratedCommandsLimitsNVX
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceFeatures2KHR = procedure(
    physicalDevice: TVkPhysicalDevice;
    pFeatures: PVkPhysicalDeviceFeatures2KHR
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceProperties2KHR = procedure(
    physicalDevice: TVkPhysicalDevice;
    pProperties: PVkPhysicalDeviceProperties2KHR
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceFormatProperties2KHR = procedure(
    physicalDevice: TVkPhysicalDevice;
    format: TVkFormat;
    pFormatProperties: PVkFormatProperties2KHR
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceImageFormatProperties2KHR = function(
    physicalDevice: TVkPhysicalDevice;
    pImageFormatInfo: PVkPhysicalDeviceImageFormatInfo2KHR;
    pImageFormatProperties: PVkImageFormatProperties2KHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceQueueFamilyProperties2KHR = procedure(
    physicalDevice: TVkPhysicalDevice;
    pQueueFamilyPropertyCount: Puint32_t;
    pQueueFamilyProperties: PVkQueueFamilyProperties2KHR
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceMemoryProperties2KHR = procedure(
    physicalDevice: TVkPhysicalDevice;
    pMemoryProperties: PVkPhysicalDeviceMemoryProperties2KHR
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceSparseImageFormatProperties2KHR = procedure(
    physicalDevice: TVkPhysicalDevice;
    pFormatInfo: PVkPhysicalDeviceSparseImageFormatInfo2KHR;
    pPropertyCount: Puint32_t;
    pProperties: PVkSparseImageFormatProperties2KHR
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdPushDescriptorSetKHR = procedure(
    commandBuffer: TVkCommandBuffer;
    pipelineBindPoint: TVkPipelineBindPoint;
    layout: TVkPipelineLayout;
    set_: uint32_t;
    descriptorWriteCount: uint32_t;
    pDescriptorWrites: PVkWriteDescriptorSet
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkTrimCommandPoolKHR = procedure(
    device: TVkDevice;
    commandPool: TVkCommandPool;
    flags: TVkCommandPoolTrimFlagsKHR
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceExternalBufferPropertiesKHX = procedure(
    physicalDevice: TVkPhysicalDevice;
    pExternalBufferInfo: PVkPhysicalDeviceExternalBufferInfoKHX;
    pExternalBufferProperties: PVkExternalBufferPropertiesKHX
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{$IFDEF VK_USE_PLATFORM_WIN32_KHX}
  TvkGetMemoryWin32HandleKHX = function(
    device: TVkDevice;
    memory: TVkDeviceMemory;
    handleType: TVkExternalMemoryHandleTypeFlagBitsKHX;
    pHandle: PHANDLE
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_WIN32_KHX}

{$IFDEF VK_USE_PLATFORM_WIN32_KHX}
  TvkGetMemoryWin32HandlePropertiesKHX = function(
    device: TVkDevice;
    handleType: TVkExternalMemoryHandleTypeFlagBitsKHX;
    handle: THANDLE;
    pMemoryWin32HandleProperties: PVkMemoryWin32HandlePropertiesKHX
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_WIN32_KHX}

  TvkGetMemoryFdKHX = function(
    device: TVkDevice;
    memory: TVkDeviceMemory;
    handleType: TVkExternalMemoryHandleTypeFlagBitsKHX;
    pFd: Pint
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetMemoryFdPropertiesKHX = function(
    device: TVkDevice;
    handleType: TVkExternalMemoryHandleTypeFlagBitsKHX;
    fd: int;
    pMemoryFdProperties: PVkMemoryFdPropertiesKHX
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceExternalSemaphorePropertiesKHX = procedure(
    physicalDevice: TVkPhysicalDevice;
    pExternalSemaphoreInfo: PVkPhysicalDeviceExternalSemaphoreInfoKHX;
    pExternalSemaphoreProperties: PVkExternalSemaphorePropertiesKHX
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{$IFDEF VK_USE_PLATFORM_WIN32_KHX}
  TvkGetSemaphoreWin32HandleKHX = function(
    device: TVkDevice;
    semaphore: TVkSemaphore;
    handleType: TVkExternalSemaphoreHandleTypeFlagBitsKHX;
    pHandle: PHANDLE
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_WIN32_KHX}

{$IFDEF VK_USE_PLATFORM_WIN32_KHX}
  TvkImportSemaphoreWin32HandleKHX = function(
    device: TVkDevice;
    pImportSemaphoreWin32HandleInfo: PVkImportSemaphoreWin32HandleInfoKHX
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_WIN32_KHX}

  TvkGetSemaphoreFdKHX = function(
    device: TVkDevice;
    semaphore: TVkSemaphore;
    handleType: TVkExternalSemaphoreHandleTypeFlagBitsKHX;
    pFd: Pint
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkImportSemaphoreFdKHX = function(
    device: TVkDevice;
    pImportSemaphoreFdInfo: PVkImportSemaphoreFdInfoKHX
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkReleaseDisplayEXT = function(
    physicalDevice: TVkPhysicalDevice;
    display: TVkDisplayKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{$IFDEF VK_USE_PLATFORM_XLIB_XRANDR_EXT}
  TvkAcquireXlibDisplayEXT = function(
    physicalDevice: TVkPhysicalDevice;
    dpy: PDisplay;
    display: TVkDisplayKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_XLIB_XRANDR_EXT}

{$IFDEF VK_USE_PLATFORM_XLIB_XRANDR_EXT}
  TvkGetRandROutputDisplayEXT = function(
    physicalDevice: TVkPhysicalDevice;
    dpy: PDisplay;
    rrOutput: TRROutput;
    pDisplay: PVkDisplayKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_XLIB_XRANDR_EXT}

  TvkDisplayPowerControlEXT = function(
    device: TVkDevice;
    display: TVkDisplayKHR;
    pDisplayPowerInfo: PVkDisplayPowerInfoEXT
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkRegisterDeviceEventEXT = function(
    device: TVkDevice;
    pDeviceEventInfo: PVkDeviceEventInfoEXT;
    pAllocator: PVkAllocationCallbacks;
    pFence: PVkFence
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkRegisterDisplayEventEXT = function(
    device: TVkDevice;
    display: TVkDisplayKHR;
    pDisplayEventInfo: PVkDisplayEventInfoEXT;
    pAllocator: PVkAllocationCallbacks;
    pFence: PVkFence
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetSwapchainCounterEXT = function(
    device: TVkDevice;
    swapchain: TVkSwapchainKHR;
    counter: TVkSurfaceCounterFlagBitsEXT;
    pCounterValue: Puint64_t
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceSurfaceCapabilities2EXT = function(
    physicalDevice: TVkPhysicalDevice;
    surface: TVkSurfaceKHR;
    pSurfaceCapabilities: PVkSurfaceCapabilities2EXT
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkEnumeratePhysicalDeviceGroupsKHX = function(
    instance: TVkInstance;
    pPhysicalDeviceGroupCount: Puint32_t;
    pPhysicalDeviceGroupProperties: PVkPhysicalDeviceGroupPropertiesKHX
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDeviceGroupPeerMemoryFeaturesKHX = procedure(
    device: TVkDevice;
    heapIndex: uint32_t;
    localDeviceIndex: uint32_t;
    remoteDeviceIndex: uint32_t;
    pPeerMemoryFeatures: PVkPeerMemoryFeatureFlagsKHX
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkBindBufferMemory2KHX = function(
    device: TVkDevice;
    bindInfoCount: uint32_t;
    pBindInfos: PVkBindBufferMemoryInfoKHX
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkBindImageMemory2KHX = function(
    device: TVkDevice;
    bindInfoCount: uint32_t;
    pBindInfos: PVkBindImageMemoryInfoKHX
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetDeviceMaskKHX = procedure(
    commandBuffer: TVkCommandBuffer;
    deviceMask: uint32_t
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDeviceGroupPresentCapabilitiesKHX = function(
    device: TVkDevice;
    pDeviceGroupPresentCapabilities: PVkDeviceGroupPresentCapabilitiesKHX
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDeviceGroupSurfacePresentModesKHX = function(
    device: TVkDevice;
    surface: TVkSurfaceKHR;
    pModes: PVkDeviceGroupPresentModeFlagsKHX
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkAcquireNextImage2KHX = function(
    device: TVkDevice;
    pAcquireInfo: PVkAcquireNextImageInfoKHX;
    pImageIndex: Puint32_t
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDispatchBaseKHX = procedure(
    commandBuffer: TVkCommandBuffer;
    baseGroupX: uint32_t;
    baseGroupY: uint32_t;
    baseGroupZ: uint32_t;
    groupCountX: uint32_t;
    groupCountY: uint32_t;
    groupCountZ: uint32_t
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDevicePresentRectanglesKHX = function(
    physicalDevice: TVkPhysicalDevice;
    surface: TVkSurfaceKHR;
    pRectCount: Puint32_t;
    pRects: PVkRect2D
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateDescriptorUpdateTemplateKHR = function(
    device: TVkDevice;
    pCreateInfo: PVkDescriptorUpdateTemplateCreateInfoKHR;
    pAllocator: PVkAllocationCallbacks;
    pDescriptorUpdateTemplate: PVkDescriptorUpdateTemplateKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyDescriptorUpdateTemplateKHR = procedure(
    device: TVkDevice;
    descriptorUpdateTemplate: TVkDescriptorUpdateTemplateKHR;
    pAllocator: PVkAllocationCallbacks
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkUpdateDescriptorSetWithTemplateKHR = procedure(
    device: TVkDevice;
    descriptorSet: TVkDescriptorSet;
    descriptorUpdateTemplate: TVkDescriptorUpdateTemplateKHR;
    pData: Pointer
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdPushDescriptorSetWithTemplateKHR = procedure(
    commandBuffer: TVkCommandBuffer;
    descriptorUpdateTemplate: TVkDescriptorUpdateTemplateKHR;
    layout: TVkPipelineLayout;
    set_: uint32_t;
    pData: Pointer
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkSetHdrMetadataEXT = procedure(
    device: TVkDevice;
    swapchainCount: uint32_t;
    (*
      Number of swap chains to update in this call
    *)

    pSwapchains: PVkSwapchainKHR;
    (*
      Swapchains to present an image from
    *)

    pMetadata: PVkHdrMetadataEXT
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetRefreshCycleDurationGOOGLE = function(
    device: TVkDevice;
    swapchain: TVkSwapchainKHR;
    pDisplayTimingProperties: PVkRefreshCycleDurationGOOGLE
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPastPresentationTimingGOOGLE = function(
    device: TVkDevice;
    swapchain: TVkSwapchainKHR;
    pPresentationTimingCount: Puint32_t;
    pPresentationTimings: PVkPastPresentationTimingGOOGLE
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{$IFDEF VK_USE_PLATFORM_IOS_MVK}
  TvkCreateIOSSurfaceMVK = function(
    instance: TVkInstance;
    pCreateInfo: PVkIOSSurfaceCreateInfoMVK;
    pAllocator: PVkAllocationCallbacks;
    pSurface: PVkSurfaceKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_IOS_MVK}

{$IFDEF VK_USE_PLATFORM_MACOS_MVK}
  TvkCreateMacOSSurfaceMVK = function(
    instance: TVkInstance;
    pCreateInfo: PVkMacOSSurfaceCreateInfoMVK;
    pAllocator: PVkAllocationCallbacks;
    pSurface: PVkSurfaceKHR
  ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
{$ENDIF VK_USE_PLATFORM_MACOS_MVK}

  TvkCmdSetViewportWScalingNV = procedure(
    commandBuffer: TVkCommandBuffer;
    firstViewport: uint32_t;
    viewportCount: uint32_t;
    pViewportWScalings: PVkViewportWScalingNV
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetDiscardRectangleEXT = procedure(
    commandBuffer: TVkCommandBuffer;
    firstDiscardRectangle: uint32_t;
    discardRectangleCount: uint32_t;
    pDiscardRectangles: PVkRect2D
  ); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};


